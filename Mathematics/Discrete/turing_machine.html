---
layout: default
title: Turing Machines
topic_id: disc-6
level: detail
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body>
        {% include learning_resource_schema.html topic_id=page.topic_id %}

        <div class="hero-section">
            <h1 class="webpage-name">Turing Machines</h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#TM">Turing Machines</a>
            <a href="#algo">Algorithms</a>
            <a href="#unsolve">Unsolvability</a>
        </div> 

        <div class="container">  
           
            <section id="TM" class="section-content">
                <h2>Turing Machines (TMs)</h2>

                 <p>
                    We saw that <a href="intro_automata.html"><strong>finite automata</strong></a> recognize regular languages 
                    and <a href="context_free.html"><strong>pushdown automata</strong></a> recognize context-free languages, but 
                    both models have fundamental limitations. The <strong>Turing machine</strong>, introduced by Alan Turing, 
                    removes these limitations by providing an infinite tape that serves as both input and unbounded read/write memory. 
                    It is the standard model for defining what it means to <em>compute</em>.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Turing Machine</span>
                    <p>
                        A <strong>Turing machine</strong> is a 7-tuple \((Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})\) where 
                        \(Q, \Sigma, \Gamma\) are finite sets and
                    </p>
                    <ul style="padding-left: 40px;">
                        <li>\(Q\) is the set of states,</li>
                        <li>\(\Sigma\) is the input alphabet, not containing the <strong>blank symbol</strong> \(\sqcup\),</li>
                        <li>\(\Gamma\) is the <strong>tape alphabet</strong>, where \(\sqcup \in \Gamma\) and \(\Sigma \subseteq \Gamma\),</li>
                        <li>\(\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}\) is the transition function,</li>
                        <li>\(q_0 \in Q\) is the start state,</li>
                        <li>\(q_{accept} \in Q\) is the accept state,</li>
                        <li>\(q_{reject} \in Q\) is the reject state, where \(q_{accept} \neq q_{reject}\).</li>
                    </ul>
                </div>

                <p>
                    The key differences between a Turing machine and a finite automaton are:
                </p>

                <ul style="padding-left: 40px;">
                    <li>The tape has <strong>infinite</strong> length. Initially it contains the input string, 
                        with blank symbols (\(\sqcup\)) filling every other cell.</li>
                    <li>A Turing machine can both read symbols from the tape and <strong>write</strong> symbols on it.</li>
                    <li>The read-write head can <strong>move both left</strong> (L) <strong>and right</strong> (R). 
                        To store information, the machine writes it on the tape; to retrieve it later, the head 
                        moves back to where it was written.</li>
                    <li>The accept and reject states take effect <strong>immediately</strong> upon entry. 
                        A computation therefore has three possible outcomes: accept, reject, or <strong>loop</strong> 
                        (run forever without halting).</li>
                </ul>

                <p>
                    A Turing machine is strictly more powerful than any finite automaton or pushdown automaton, and is believed 
                    to capture the full power of any real computer. If a problem cannot be solved by a Turing machine, it is 
                    beyond the theoretical limits of computation.
                </p>

                <p>
                    At each step, a Turing machine's state of computation is captured by a <strong>configuration</strong>, 
                    which records three items:
                </p>

                <ul style="padding-left: 40px;">
                    <li><strong>Current state</strong></li>
                    <li><strong>Current tape contents</strong></li>
                    <li><strong>Current head location</strong></li>
                </ul>

                <p>
                    For example, the configuration
                    \[
                    1001\, q_5\, 0110
                    \]
                    represents a tape containing \(10010110\), with the machine in state \(q_5\) and the head positioned 
                    on the fifth symbol (the first 0 after the state label).
                </p>

                <p>
                    A Turing machine \(M\) accepts input \(w\) if there exists a sequence of configurations \(C_1, C_2, \ldots, C_k\) such that:
                </p>

                <ul style="padding-left: 40px;">
                    <li>\(C_1\) is the <strong>start configuration</strong> of \(M\) on \(w\).</li>
                    <li>\(C_i\)  yields \(C_{i+1}\).</li>
                    <li>\(C_k\) is an <strong>accepting configuration</strong>.</li>
                </ul>

                <p>
                    The collection of strings that \(M\) accepts is the <strong>language of \(M\)</strong>, denoted \(L(M)\).
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Turing-Recognizable and Turing-Decidable</span>
                    <p>
                        A language \(L\) is <strong>Turing-recognizable</strong> (or <strong>recursively enumerable</strong>) 
                        if some Turing machine recognizes it - that is, the machine accepts every string in \(L\), 
                        but may loop forever on strings not in \(L\).
                    </p>
                    <p>
                        A language \(L\) is <strong>Turing-decidable</strong> (or simply <strong>decidable</strong>) if some 
                        Turing machine decides it â€” that is, the machine halts on <em>every</em> input, accepting strings in 
                        \(L\) and rejecting strings not in \(L\).
                    </p>
                </div>

                <p>
                    Every decidable language is Turing-recognizable, but the converse does not hold - some Turing-recognizable 
                    languages are not decidable. The distinction hinges on whether the machine is guaranteed to halt.
                </p>

                <div class="proof">
                    <span class="proof-title">Example:</span> 
                    <p>
                        Consider a language 
                        \[
                        L_1 = \{0^{2^n} | n \geq 0\}
                        \]
                        which generates all strings of \(0\)s whose length is a power of 2. 
                    </p>
                    <p>
                        A Turing machine \(M_1\) must decide \(L_1\): 
                    </p>
                    <p>
                        \(M_1 = \) "On input string \(w\): "
                    </p>
                    <ol style="padding-left: 40px;">
                        <li>Read left to right across the tape, crossing out every other \(0\).</li>
                        <li>If in Stage 1, the tape contained a single \(0\), <strong>accept</strong>.</li>
                        <li>If in Stage 1, the tape contained more than a single \(0\) and the number of \(0\)s was odd, <strong>reject</strong>.</li>
                        <li>Return the head to the left-hand end of the tape.</li>
                        <li>Go back to Stage 1."</li>
                    </ol>
                    <p>
                        \(Q = \{q_1, q_2, q_3, q_4, q_5, q_{accept}, q_{reject}\}, \, \Sigma = \{0\}, \, \Gamma = \{0, \text{ x }, \sqcup\}\), and the state diagram 
                        is as follows: 
                    </p>
                    <div style="text-align: center;">
                        <img src="Images/TM1.jpg" alt="TM1"  class="responsive-image">
                    </div>
                    <p>
                        For example, if input is \(0000\), the sequence of configurations is as follows
                        \[
                        \begin{align*}
                        &q_1 0 0 0 0 \Rightarrow \sqcup q_2 0 0 0 \Rightarrow \sqcup \text{x} q_3 0 0 \Rightarrow \sqcup \text{x} 0 q_4 0  \\\\
                        &\Rightarrow \sqcup \text{x} 0 \text{x} q_3 \sqcup \Rightarrow \sqcup \text{x} 0  q_5 \text{x} \sqcup \Rightarrow  \sqcup \text{x} q_5 0 \text{x} \sqcup \\\\
                        &\Rightarrow \sqcup q_5 \text{x} 0 \text{x} \sqcup \Rightarrow  q_5 \sqcup \text{x} 0 \text{x} \sqcup \Rightarrow \sqcup q_2 \text{x} 0 \text{x} \sqcup  \\\\
                        &\Rightarrow \sqcup \text{x} q_2 0 \text{x} \sqcup \Rightarrow \sqcup \text{x} \text{x} q_3 \text{x} \sqcup \Rightarrow \sqcup \text{x} \text{x} \text{x} q_3 \sqcup \\\\
                        &\Rightarrow \sqcup \text{x} \text{x} q_5 \text{x} \sqcup \Rightarrow \sqcup \text{x} q_5 \text{x} \text{x} \sqcup \Rightarrow \sqcup q_5 \text{x} \text{x} \text{x} \sqcup \\\\
                        &\Rightarrow q_5 \sqcup \text{x} \text{x} \text{x} \sqcup \Rightarrow \sqcup q_2 \text{x} \text{x} \text{x} \sqcup \Rightarrow \sqcup \text{x} q_2 \text{x} \text{x} \sqcup \\\\
                        &\Rightarrow \sqcup \text{x} \text{x} q_2 \text{x} \sqcup \Rightarrow \sqcup \text{x} \text{x} \text{x} q_2 \sqcup \Rightarrow \sqcup \text{x} \text{x} \text{x} \sqcup q_{accept}.
                        \end{align*}
                        \]
                    </p>
                </div>
            </section>

            <section id="algo" class="section-content">
                <h2>Algorithms</h2>

                <p>
                    An <strong>algorithm</strong> is an effective procedure - a finite sequence of precise instructions that, given an input, 
                    produces an output in a finite number of steps. Although algorithms have been used throughout the history of mathematics 
                    (Euclid's algorithm for GCD dates to ~300 BCE), they were not given a precise mathematical definition until 1936, when 
                    Alonzo Church (via the \(\lambda\)-calculus) and Alan Turing (via the Turing machine) independently formalized the concept.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Church-Turing Thesis</span>
                    <p>
                        Every effective algorithm can be implemented as a Turing machine. Equivalently, 
                        any function computable by an algorithm (in the intuitive sense) is computable by a Turing machine.
                    </p>
                </div>

                <p>
                    The Church-Turing thesis is not a theorem (it cannot be formally proved, since "algorithm" in the intuitive sense is not 
                    a formal concept), but it is universally accepted and has been supported by every proposed alternative model of computation 
                    turning out to be equivalent to Turing machines in power.
                </p>

                <p>
                    Now we have a fundamental question: are there problems that <em>no</em> algorithm can solve? Remarkably, the answer is yes. 
                    Studying <strong>unsolvability</strong> is valuable for two reasons. First, recognizing that a problem is algorithmically 
                    unsolvable guides us to modify or relax it into a tractable variant. Second, understanding the absolute limits of computation 
                    provides deep insight into the structure of problems themselves.
                </p>
 
                <p>
                    We summarize the key facts about the decidability hierarchy. These results establish the relationships 
                    among the language classes we have studied.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Theorem: Decidability Hierarchy</span>
                    <ul style="padding-left: 40px;">
                        <li>Every context-free language (CFL) is <strong>decidable</strong>.</li>
                        <li>Some Turing-recognizable languages are <strong>undecidable</strong>.</li>
                        <li>A language is decidable if and only if both it and its complement are Turing-recognizable 
                            (i.e., it is both Turing-recognizable and <strong>co-Turing-recognizable</strong>).</li>
                    </ul>
                    <div style="text-align: center;">
                        <img src="Images/language_class.jpg" alt="Language_Class"  class="responsive-image">
                    </div>
                </div>
                <p>
                    Note: Modern computers are essentially finite versions of Turing machines (more precisely, random-access machines (RAM) with bounded memory).
                    Any algorithm that runs on a real computer can, in principle, be translated into a Turing machine, although it may be inefficient.
                </p>
        </section>

        <section id="unsolve" class="section-content">
            <h2>Unsolvability</h2>

            <p>
                The existence of undecidable languages still leaves open the possibility that every language is at least <em>recognizable</em>. 
                The following theorem shows that even this weaker condition fails - there are languages beyond the reach of any Turing machine 
                whatsoever.
            </p>

            <div class="theorem">
                <span class="theorem-title">Theorem: Existence of Non-Recognizable Languages</span>
                <p>
                    Some languages are <strong>not</strong> Turing-recognizable.
                </p>
            </div>
            
            <div class="proof">
                <span class="proof-title">Proof:</span> 
                <p>
                    First, we show that the set of all Turing machines is countable. 
                    Note that each Turing machine \(M\) can be encoded as a finite string \(\langle M \rangle\) over some alphabet \(\Sigma\).
                    The set of all strings \(\Sigma^*\) over the alphabet \(\Sigma\) can be written as 
                    \[
                    \Sigma^* = \bigcup_{n \geq 0} \Sigma^n,
                    \]
                    where \(n\) is any nonnegative integer, and \(\Sigma^n\) is the set of strings of length \(n\). 
                    Since each \(\Sigma^n\) is finite and a countable union of finite sets is countable, it follows that \(\Sigma^*\) is countable. 
                    Since every Turing machine \(M\) can be encoded as a finite string \(\langle M \rangle \in \Sigma^*\), the set of all 
                    Turing machines is a subset of \(\Sigma^*\). As any subset of a countable set is countable, it follows that the set of all 
                    Turing machines is countable.
                </p>
                <p>
                    Next, we show that the set of all languages is uncountable.
                    Let \(B\) be the set of all infinite binary sequences, defined as \(B = \{b: \mathbb{N} \to \{0, 1\}\}\). 
                    It is known that \(B\) is uncountable because it can be placed in one-to-one correspondence with the power set 
                    of \(\mathbb{N}\), which has a strictly greater cardinality than \(\mathbb{N}\). Each language over \(\Sigma\) is 
                    any subset of \(\Sigma^*\). Thus, the set of all languages over alphabet \(\Sigma\) is written as
                    \[
                    L = \mathcal{P}(\Sigma^*).
                    \]
                    Since \(\Sigma^*\) is countable, we can enumerate it as
                    \[
                    \Sigma^* = \{s_1, s_2, s_3, \ldots \}.
                    \]
                    For any language \(A \in L\), define its characteristic sequence \(\chi_A\) by 
                    \[
                    \chi_A (i) = \begin{cases}
                                    1, &\text{if  \(s_i \in A\)} \\
                                    0, &\text{if \(s_i \notin A\)}
                                    \end{cases}.
                    \]
                    Define the function \(f: L \to B\) by \(f(A) = \chi_A\).
                    If \(A \neq A'\), then there exists some index \(i\) for which \(s_i\) is in one of \(A\) or \(A'\) but 
                    not the other, so \(\chi_A (i) \neq \chi_{A'} (i) \). Also, for any infinite binary sequence \(b \in B\), 
                    define the language \(A_b = \{s_i \in \Sigma^* : b(i) = 1\}\). Then \(f(A_b) = b\). Thus, \(f\) is a 
                    bijection between \(L = \mathcal{P}(\Sigma^*)\) and \(B\).
                </p>
                <p>
                    Since \(B\) is uncountable and there is a bijection \(f\) between \(L\) and \(B\), it follows that 
                    the set of all languages over \(\Sigma\) is uncountable. 
                </p>
                <p>
                    Therefore, since the set of all Turing machines is countable, and the set of all languages is 
                    uncountable, there exist languages that cannot be recognized by any Turing machine.
                </p>
            </div>

            <p>
                This is one of the most profound results in mathematics: there exist well-defined problems that 
                <em>no algorithm can ever solve</em>. However, many practically important problems that are 
                undecidable or intractable in the worst case can still be addressed through 
                <strong>approximation algorithms</strong> and <strong>heuristics</strong>, which find good 
                (if not provably optimal) solutions in reasonable time.
            </p>

            <p>
                Having established what is and is not computable, we next ask: among the decidable problems, 
                how <em>efficiently</em> can they be solved? This is the subject of 
                <a href="time_complexity.html"><strong>time complexity</strong></a>.
            </p>
            
            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>