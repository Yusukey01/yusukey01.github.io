<!DOCTYPE html>
<html>
    <head> 
        <title>Class P vs NP</title>
        <link rel="stylesheet" href="../styles.css">
        <script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="https://cdn.jsdelivr.net/pyodide/v0.23.3/full/pyodide.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body> 
        <div class="toc-container">
            <h2>Contents</h2>
            <ul>
                <li><a href="#P_verify">Polynomial Verifiability</a></li>
                <li><a href="#NP">Nondeterministic Polynomial Time(NP)</a></li>
                <li><a href="#P=NP">P vs NP Question<</a></li>
            </ul>
        </div>

        <h1 id="P_verify">Polynomial Verifiability</h1>
        <blockquote>
            Problem: Given a graph, does there exist a path that visits every vertex exactly once but does not necessarily 
            return to the starting vertex? This path is called a <strong>Hamiltonian path</strong>.
            (This is similar to the <a href="Eulerian.html">Hamiltonian cycle problem</a>.)
            <br><br>
            Like the Hamiltonian cycle problem, this problem also has a feature called <strong>polynomial verifiability</strong>.
            Even though we cannot determine the existence of the path in polynomial time(it require exponential time in the worst case), 
            if such a path is given, we could easily verify its existence. Here, we introduce a formal definition:
            <div class="theorem">
                <span class="theorem-title">Verifiability: </span>
                A <strong>verifier</strong> for a language \(A\) is an algorithm \(V\), where 
                \[
                A = \{w \, | V \text{ accepts } \langle w, c \rangle \text{ for some string } c \}.
                \]
                We measure the time of a verifier only in terms of the length of \(w\), so a polynomial time verifier runs 
                in polynomial time in the length of \(w\). A language \(A\) is <strong>polynomially verifiable</strong> if 
                it has a polynomial time verifier. The string \(c\) is called a <strong>certificate</strong> of membership in \(A\). 
            </div>
            (In the context of the Hamiltonian path problem, the certificate can be a specific Hamiltonian path.)
        </blockquote>

        <h1 id="NP">Nondeterministic Polynomial Time (NP)</h1>
        <blockquote>
            <div class="theorem">
                <span class="theorem-title">Class NP: </span>
                <strong>NP</strong> is the class of languages that have polynomial time verifiers.
            </div>
            There is a <strong>nondeterministic Turing machine (NTM)</strong> that decides the Hamiltonian path problem 
            in <strong>nondeterministic polynomial time</strong>. In general, a language is in NP if and only if it is 
            decided by some nondeterministic polynomial time Turing machine. (A polynomial time verifier == some NTM)
            Also, we define the nondeterministic time complexity class as following:
            <div class="theorem">
                <span class="theorem-title"> Nondeterministic Time Complexity Class: </span>
                \[
                \text{NTIME}(t(n)) = \{L | \text{ L is a language decided by an } O(t(n)) \text{ time nondeterministic Turing machine.}\}
                \]
                Moreover, 
                \[
                NP = \bigcup_k \text{ NTIME }(n^k).
                \]
            </div>
        </blockquote>

        <h1 id="P=NP">P vs NP Question</h1>
        <blockquote>
            <ul>
                <li>P is the class of languages for which membership can be <strong>decided</strong> in polynomial time.</li>
                <li>NP is the class of languages for which membership can be <strong>verified</strong> in polynomial time.</li>
            </ul>
            We know the Hamiltonian path problem is in NP, but that are "not known" to be in P. Intuitively, it seems like polynomial 
            verifiability has greater power than polynomial decidability. However, it is still an open question whether there are problems 
            in NP that are not in P. In other words, we don't know if \(P = NP\) or \(P \neq NP\) mathematically.
            (So far, most researchers believe that the two classes are not equal.)
        </blockquote>

        <h1 id=""></h1>
        <blockquote>
        </blockquote>

        <a href="../../index.html">Back to Home </a>
        <br> <a href="discrete_math.html">Back to Discrete Mathematics & Algorithms</a>

        <script src="../runPythonCode.js"></script>
        <script src="../collapsible.js"></script>
    </body>
</html>