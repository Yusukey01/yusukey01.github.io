<!DOCTYPE html>
<html>
    <head> 
        <title>Class P vs NP</title>
        <link rel="stylesheet" href="../styles.css">
        <script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="https://cdn.jsdelivr.net/pyodide/v0.23.3/full/pyodide.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body> 
        <div class="toc-container">
            <h2>Contents</h2>
            <ul>
                <li><a href="#P_verify">Polynomial Verifiability</a></li>
                <li><a href="#NP">Nondeterministic Polynomial Time(NP)</a></li>
                <li><a href="#"></a></li>
            </ul>
        </div>

        <h1 id="P_verify">Polynomial Verifiability</h1>
        <blockquote>
            Problem: Given a graph, does there exist a path that visits every vertex exactly once but does not necessarily 
            return to the starting vertex? This path is called a <strong>Hamiltonian path</strong>.
            <br>
            (This is similar to the <a href="Eulerian.html">Hamiltonian cycle problem</a>.)
            <br><br>
            Like the Hamiltonian cycle problem, this problem also has a feature called <strong>polynomial verifiability</strong>.
            Even though we cannot determine the existence of the path in polynomial time(it require exponential time in the worst case), 
            if such a path is given, we could easily verify its existence. Here, we introduce a formal definition:
            <div class="theorem">
                <span class="theorem-title">Verifiability: </span>
                A <strong>verifier</strong> for a language \(A\) is an algorithm \(V\), where 
                \[
                A = \{w \, | V \text{ accepts } \langle w, c \rangle \text{ for some string } c \}.
                \]
                We measure the time of a verifier only in terms of the length of \(w\), so a polynomial time verifier runs 
                in polynomial time in the length of \(w\). A language \(A\) is <strong>polynomially verifiable</strong> if 
                it has a polynomial time verifier. 
                <br>
                The string \(c\) is called a <strong>certificate</strong> of membership in \(A\). 
            </div>
            (In the context of the Hamiltonian path problem, the certificate can be a specific Hamiltonian path.)
        </blockquote>

        <h1 id="NP">Nondeterministic Polynomial Time (NP)</h1>
        <blockquote>
            <div class="theorem">
                <span class="theorem-title">Class NP: </span>
                <strong>NP</strong> is the class of languages that have polynomial time verifiers.
            </div>
            There is a <strong>nondeterministic Turing machine (NTM)</strong> that decides the Hamiltonian path problem 
            in <strong>nondeterministic polynomial time</strong>. In general, a language is in NP if and only if it is 
            decided by some nondeterministic polynomial time Turing machine. (A polynomial time verifier == some NTM)
        </blockquote>

        <h1 id=""></h1>
        <blockquote>
        </blockquote>

        <a href="../../index.html">Back to Home </a>
        <br> <a href="discrete_math.html">Back to Discrete Mathematics & Algorithms</a>

        <script src="../runPythonCode.js"></script>
        <script src="../collapsible.js"></script>
    </body>
</html>