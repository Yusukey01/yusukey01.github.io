---
layout: default
title: Class NP
topic_id: disc-9
level: detail
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body>
        {% include learning_resource_schema.html topic_id=page.topic_id %}
        
        <div class="hero-section">
            <h1 class="webpage-name">Class NP</h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#P_verify">Polynomial Verifiability</a>
            <a href="#NP">Nondeterministic Polynomial Time (NP)</a>
            <a href="#P=NP">P vs NP Question</a>
            <a href="#comp">NP-Completeness</a>
        </div> 

        <div class="container">  
           
            <section id="P_verify" class="section-content">
                <h2>Polynomial Verifiability</h2>

                <p>
                    The <a href="Eulerian.html"><strong>Hamiltonian cycle problem</strong></a> illustrates an important phenomenon 
                    called <strong>polynomial verifiability</strong>. Although no known algorithm can determine whether a Hamiltonian 
                    cycle exists in polynomial time (the best known algorithms require exponential time), if someone <em>hands us</em> 
                    a proposed cycle, we can verify that it is indeed a valid Hamiltonian cycle in polynomial time - simply by checking 
                    that it visits every vertex exactly once.
                </p>
                
                <div class="theorem">
                    <span class="theorem-title">Definition: Verifiability</span>
                    <p>
                        A <strong>verifier</strong> for a language \(A\) is an algorithm \(V\) such that
                        \[
                        A = \{w \mid V \text{ accepts } \langle w, c \rangle \text{ for some string } c\}.
                        \]
                        We measure the time of a verifier only in terms of the length of \(w\), so a polynomial time verifier runs 
                        in polynomial time in the length of \(w\). A language \(A\) is <strong>polynomially verifiable</strong> if 
                        it has a polynomial time verifier. The string \(c\) is called a <strong>certificate</strong> of membership in \(A\). 
                    </p>
                </div>
                <p>
                    (In the context of the Hamiltonian cycle problem, the certificate can be a specific Hamiltonian cycle.)
                </p>
            </section>

            <section id="NP" class="section-content">
                <h2>Nondeterministic Polynomial Time (NP)</h2>
                
                <div class="theorem">
                    <span class="theorem-title">Definition: Class NP</span>
                    <p>
                        <strong>NP</strong> is the class of languages that have polynomial time verifiers.
                    </p>
                </div>

                <p>
                    There is an equivalent characterization of NP using <strong>nondeterministic Turing machines (NTMs)</strong>. 
                    A language is in NP if and only if it is decided by some nondeterministic polynomial-time Turing machine. 
                    The two definitions - polynomial-time verifier and nondeterministic polynomial-time decider - are equivalent.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Nondeterministic Time Complexity Class</span>
                    <p>
                        \[
                        \text{NTIME}(t(n)) = \{L \mid L \text{ is a language decided by an } O(t(n))\text{-time nondeterministic Turing machine}\}.
                        \]
                        Equivalently,
                        \[
                        NP = \bigcup_k \text{NTIME}(n^k).
                        \]
                    </p>
                </div>
                
            </section>

            <section id="P=NP" class="section-content">
                <h2>P vs NP Question</h2>
                
                <ul  style="padding-left: 40px;">
                    <li>P is the class of languages for which membership can be <strong>decided</strong> in polynomial time.</li>
                    <li>NP is the class of languages for which membership can be <strong>verified</strong> in polynomial time.</li>
                </ul>

                <p>
                    Problems like the Hamiltonian cycle are known to be in NP but are not known to be in P. Intuitively, it seems that 
                    verifying a solution should be easier than finding one - but this has never been proved. The question of whether 
                    \(P = NP\) or \(P \neq NP\) is one of the most important open problems in mathematics and computer science, listed among the 
                    Clay Mathematics Institute's <strong>Millennium Prize Problems</strong> (with a \\($1\) million prize). 
                    Most researchers believe that \(P \neq NP\).
                </p>

                <p>
                    What is known is the containment
                    \[
                    P \subseteq NP \subseteq \text{EXPTIME} = \bigcup_k \text{TIME}(2^{n^k}).
                    \]
                    Whether either inclusion is strict remains open.
                </p>

            </section>

            <section id="comp" class="section-content">
                <h2>NP-Completeness</h2>

                <p>
                    Some problems in NP are as hard as <em>any</em> problem in NP - solving any one of them in 
                    polynomial time would imply \(P = NP\). These are the <strong>NP-complete</strong> problems. 
                    The Hamiltonian cycle problem is one such example.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Polynomial Time Reduction</span>
                    <p>
                        Language \(A\) is <strong>polynomial time reducible</strong> to language \(B\), denoted 
                        \[
                        A \leq_{P} B
                        \]
                        if a <strong>polynomial time computable function</strong> \(f: \Sigma^* \to \Sigma^*\) exists, where 
                        \[
                        \forall w, \, w \in A \Longleftrightarrow f(w) \in B.
                        \]
                        The function \(f\) is called the <strong>polynomial time reduction</strong> of \(A\) to \(B\).
                    </p>

                    <p>
                        Here, a function \(f\) is <strong>polynomial-time computable</strong> if there exists a polynomial-time 
                        Turing machine \(M\) that, on any input \(w\), halts with \(f(w)\) on its tape.
                    </p>
                   
                </div>

                <div class="theorem">
                    <span class="theorem-title">Definition: NP-Completeness</span>
                    <p>
                        A language \(B\) is <strong>NP-complete</strong> if it satisfies the following two conditions:
                    </p>
                    <ol style="padding-left: 40px;">
                        <li>\(B\) is in NP.</li>
                        <li>Every language \(A\) in NP is polynomial-time reducible to \(B\) (i.e., \(A \leq_P B\)).</li>
                    </ol>
                    <p>
                        A language satisfying condition 2 (but not necessarily condition 1) is called <strong>NP-hard</strong>.
                    </p>
                </div>

                <p>
                    Finally, we introduce the Hamiltonian cycle problem with weighted edges. 
                </p>

                <div class="proof">
                    <span class="proof-title">Example: Traveling Salesperson Problem (TSP) - Decision Version</span>
                    <p>
                        Given a set of cities, the distances between them, and a number \(k\), is there a tour that visits each 
                        city exactly once, returns to the starting city, and has total distance \(\leq k\)? 
                    </p>
                </div>

                <p>
                    The decision version of TSP is NP-complete. The <strong>optimization</strong> version - which asks for the 
                    shortest possible Hamiltonian cycle â€” is <strong>NP-hard</strong> but not NP-complete, because it is not 
                    a decision problem and thus does not belong to NP in the formal sense.
                </p>

                <p>
                    Under the widely believed assumption that \(P \neq NP\), the landscape of complexity classes is as follows:
                </p>

                <div style="text-align: center;">
                    <img src="Images/complexity.jpg" alt="complexity"  class="responsive-image">
                </div>

                <p>
                    Note: If it were the case that \(P = NP\), then the classes P, NP, and NP-complete would all collapse 
                    to the same class, since every nontrivial language in P would be NP-complete. 
                    (\(P = NP = NP\text{-complete}\))
                </p>

                <p>
                    NP-completeness theory has profound practical implications: when faced with an NP-complete problem 
                    in applications such as scheduling, routing, or resource allocation, we know that finding an exact 
                    polynomial-time algorithm is almost certainly impossible. Instead, practitioners turn to 
                    approximation algorithms, heuristics, and special-case solvers.
                </p>

            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>