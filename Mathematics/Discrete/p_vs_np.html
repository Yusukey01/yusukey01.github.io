---
layout: default
title: Class P vs NP
level: detail
description: Learn about nondeterministic polynomial time(NP), and NP-Completeness.
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body>
        <div class="hero-section">
            <h1 class="webpage-name">Class P vs NP
            </h1>
        </div>

        <div class="topic-nav">
            <a href="#P_verify">Polynomial Verifiability</a>
            <a href="#NP">Nondeterministic Polynomial Time(NP)</a>
            <a href="#P=NP">P vs NP Question</a>
            <a href="#comp">NP-Completeness</a>
        </div> 

        <div class="container">  
           
            <section id="P_verify" class="section-content">
            <h2>Polynomial Verifiability</h2>
            <p>
            <a href="Eulerian.html">Hamiltonian cycle problem</a> has a feature called <strong>polynomial verifiability</strong>.
            Even though we cannot determine the existence of the path in polynomial time(it require exponential time in the worst case), 
            if such a cycle is given, we could easily verify its existence. Here, we introduce a formal definition:
            <div class="theorem">
                <span class="theorem-title">Verifiability: </span>
                A <strong>verifier</strong> for a language \(A\) is an algorithm \(V\), where 
                \[
                A = \{w \, | V \text{ accepts } \langle w, c \rangle \text{ for some string } c \}.
                \]
                We measure the time of a verifier only in terms of the length of \(w\), so a polynomial time verifier runs 
                in polynomial time in the length of \(w\). A language \(A\) is <strong>polynomially verifiable</strong> if 
                it has a polynomial time verifier. The string \(c\) is called a <strong>certificate</strong> of membership in \(A\). 
            </div>
            (In the context of the Hamiltonian cycle problem, the certificate can be a specific Hamiltonian cycle.)
            </p>
            </section>

            <section id="NP" class="section-content">
            <h2>Nondeterministic Polynomial Time (NP)</h2>
            <p>
            <div class="theorem">
                <span class="theorem-title">Class NP: </span>
                <strong>NP</strong> is the class of languages that have polynomial time verifiers.
            </div>
            There is a <strong>nondeterministic Turing machine (NTM)</strong> that decides the Hamiltonian cycle problem 
            in <strong>nondeterministic polynomial time</strong>. In general, a language is in NP if and only if it is 
            decided by some nondeterministic polynomial time Turing machine. (A polynomial time verifier == some NTM)
            Also, we define the nondeterministic time complexity class as following:
            <div class="theorem">
                <span class="theorem-title"> Nondeterministic Time Complexity Class: </span>
                \[
                \text{NTIME}(t(n)) = \{L | \text{ L is a language decided by an } O(t(n)) \text{ time nondeterministic Turing machine.}\}
                \]
                Moreover, 
                \[
                NP = \bigcup_k \text{ NTIME }(n^k).
                \]
            </div>
            </p>
            </section>

            <section id="P=NP" class="section-content">
            <h2>P vs NP Question</h2>
            <p>
            <ul  style="padding-left: 40px;">
                <li>P is the class of languages for which membership can be <strong>decided</strong> in polynomial time.</li>
                <li>NP is the class of languages for which membership can be <strong>verified</strong> in polynomial time.</li>
            </ul>
            <br>
            We know the Hamiltonian cycle problem is in NP, but that are "not known" to be in P. Intuitively, it seems like polynomial 
            verifiability has greater power than polynomial decidability. However, it is still an open question whether there are problems 
            in NP that are not in P. In other words, we don't know if \(P = NP\) or \(P \neq NP\) mathematically.
            (So far, most researchers believe that the two classes are not equal.)
            <br><br>
            Currently, it is known that 
            \[
            NP \subseteq \text{ EXPTIME} = \bigcup_k \text{ TIME } (2^{n^k}).
            \]
            </p>
            </section>

            <section id="comp" class="section-content">
            <h2>NP-Completeness</h2>
            <p>
            It is known that the Hamiltonian cycle problem is said to be <strong>NP-complete</strong>. 
            (Proofs might be updated in the future.) 
            <div class="theorem">
                <span class="theorem-title"> NP-Completeness: </span>
                A language \(B\) is <strong>NP-complete</strong> if it satisfies following conditions:
                <ul  style="padding-left: 40px;">
                    <li>\(B\) is in NP.</li>
                    <li>Every \(A\) in NP is <strong>polynomial time reducible</strong> to \(B\).</li>
                </ul>
            </div>

            <div class="theorem">
                <span class="theorem-title"> Polynomial Time Reduction: </span>
            Language \(A\) is <strong>polynomial time reducible</strong> to language \(B\), denoted 
            \[
            A \leq_{P} B
            \]
            if a <strong>polynomial time computable function</strong> \(f: \Sigma^* \to \Sigma^*\) exists, where 
            \[
            \forall w, \, w \in A \Longleftrightarrow f(w) \in B.
            \]
            The function \(f\) is called the <strong>polynomial time reduction</strong> of \(A\) to \(B\).
            <br>
            Note: If \(f\) is a polynomial time computable function, there exists a polynomial time Turing machine \(M\) that halts 
            with \(f(w)\) in its tape, when started on any input (w). 
            </div>
            Finally, we introduce the Hamiltonian cycle problem with weighted edges. 
            <div class="proof">
                <span class="proof-title">Traveling Salesperson Problem (TSP), ver. Decision</span>
                    Given a set of cities, distances between them, and a number \(k\), is there a tour that visits each 
                    city exactly once, returns to the starting city, and has total distance \(\leq k\)? 
            </div>
            This decision version problem is NP-complete, but the <strong>optimization</strong> version - which asks for the <strong>shortest</strong> 
            possible Hamiltonian cycle given edge weights - is <strong>NOT</strong> NP-complete, and it is considered as <strong>NP-hard</strong>.
            <br>
            Assume that \(P \neq NP\), then we have the following diagram about time complexity classes.
            <br>
            <div style="text-align: center;">
                <img src="Images/complexity.jpg" alt="complexity" style="width:600px;">
            </div>
            Note: If \(P = NP\), then \(P = NP = NP\text{-complete}\).
            </p>
            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>