---
layout: default
title: Class NP
level: detail
description: Learn about nondeterministic polynomial time(NP), and NP-Completeness.
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body>
        <!-- Meta script for p_vs_np.html -->
        <script type="application/ld+json">
        {
        "@context": "https://schema.org",
        "@type": "LearningResource",
        "name": "{{ page.title }}",
        "description": "{{ page.description }}",
        "learningResourceType": "lesson",
        "educationalUse": "instruction",
        "educationalLevel": "university",
        "interactivityType": "{% if page.content contains 'Interactive Demo' or page.content contains 'demo' %}active{% else %}expositive{% endif %}",
        "author": {
            "@type": "Person",
            "name": "Yusuke Yokota",
            "jobTitle": "Mathematics & Computer Science Educator"
        },
        "publisher": {
            "@type": "Organization",
            "name": "MATH-CS COMPASS",
            "url": "https://yusukey01.github.io"
        },
        "about": [
            { "@type": "Thing", "name": "Class NP" },
            { "@type": "Thing", "name": "Nondeterministic Polynomial Time" },
            { "@type": "Thing", "name": "NP-Completeness" },
            { "@type": "Thing", "name": "NP-Complete Problems" },
            { "@type": "Thing", "name": "NP-Hard Problems" },
            { "@type": "Thing", "name": "P vs NP Problem" },
            { "@type": "Thing", "name": "Polynomial Verifiability" },
            { "@type": "Thing", "name": "Polynomial Time Reduction" },
            { "@type": "Thing", "name": "Certificate" },
            { "@type": "Thing", "name": "Verifier" },
            { "@type": "Thing", "name": "Nondeterministic Turing Machine" },
            { "@type": "Thing", "name": "NTM" },
            { "@type": "Thing", "name": "Hamiltonian Cycle Problem" },
            { "@type": "Thing", "name": "Traveling Salesperson Problem" },
            { "@type": "Thing", "name": "TSP" },
            { "@type": "Thing", "name": "Decision Problems" },
            { "@type": "Thing", "name": "Optimization Problems" },
            { "@type": "Thing", "name": "Polynomial Time Computable Function" },
            { "@type": "Thing", "name": "Complexity Classes" },
            { "@type": "Thing", "name": "EXPTIME" },
            { "@type": "Thing", "name": "Computational Complexity Theory" },
            { "@type": "Thing", "name": "Millennium Prize Problems" },
            { "@type": "Thing", "name": "Theoretical Computer Science" }
        ],
        "teaches": [
            "NP complexity class fundamentals",
            "NP-completeness theory",
            "P vs NP problem analysis",
            "Polynomial reduction techniques"
        ],
        "isPartOf": {
            "@type": "Course",
            "name": "Discrete Mathematics & Algorithms",
            "description": "Explore the foundations of discrete mathematics and algorithms, covering graph theory, combinatorics, and the theory of computation",
            "provider": {
            "@type": "Organization",
            "name": "MATH-CS COMPASS",
            "url": "https://yusukey01.github.io"
            },
            "instructor": {
            "@type": "Person",
            "name": "Yusuke Yokota",
            "jobTitle": "Mathematics & Computer Science Educator"
            },
            "courseCode": "IV",
            "hasCourseInstance": {
            "@type": "CourseInstance",
            "courseMode": "online",
            "courseWorkload": "PT4H",
            "instructor": {
                "@type": "Person",
                "name": "Yusuke Yokota"
            }
            },
            "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock",
            "category": "free"
            }
        }
        }
        </script>

        <div class="hero-section">
            <h1 class="webpage-name">Class NP
            </h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#P_verify">Polynomial Verifiability</a>
            <a href="#NP">Nondeterministic Polynomial Time(NP)</a>
            <a href="#P=NP">P vs NP Question</a>
            <a href="#comp">NP-Completeness</a>
        </div> 

        <div class="container">  
           
            <section id="P_verify" class="section-content">
            <h2>Polynomial Verifiability</h2>
            <p>
            <a href="Eulerian.html">Hamiltonian cycle problem</a> has a feature called <strong>polynomial verifiability</strong>.
            Even though we cannot determine the existence of the path in polynomial time(it requires exponential time in the worst case), 
            if such a cycle is given, we could easily verify its existence. Here, we introduce a formal definition:
            <div class="theorem">
                <span class="theorem-title">Verifiability: </span>
                A <strong>verifier</strong> for a language \(A\) is an algorithm \(V\), where 
                \[
                A = \{w \, | V \text{ accepts } \langle w, c \rangle \text{ for some string } c \}.
                \]
                We measure the time of a verifier only in terms of the length of \(w\), so a polynomial time verifier runs 
                in polynomial time in the length of \(w\). A language \(A\) is <strong>polynomially verifiable</strong> if 
                it has a polynomial time verifier. The string \(c\) is called a <strong>certificate</strong> of membership in \(A\). 
            </div>
            (In the context of the Hamiltonian cycle problem, the certificate can be a specific Hamiltonian cycle.)
            </p>
            </section>

            <section id="NP" class="section-content">
            <h2>Nondeterministic Polynomial Time (NP)</h2>
            <p>
            <div class="theorem">
                <span class="theorem-title">Class NP: </span>
                <strong>NP</strong> is the class of languages that have polynomial time verifiers.
            </div>
            There is a <strong>nondeterministic Turing machine (NTM)</strong> that decides the Hamiltonian cycle problem 
            in <strong>nondeterministic polynomial time</strong>. In general, a language is in NP if and only if it is 
            decided by some nondeterministic polynomial time Turing machine. (A polynomial time verifier == some NTM)
            Also, we define the nondeterministic time complexity class as following:
            <div class="theorem">
                <span class="theorem-title"> Nondeterministic Time Complexity Class: </span>
                \[
                \text{NTIME}(t(n)) = \{L | \text{ L is a language decided by an } O(t(n)) \text{ time nondeterministic Turing machine.}\}
                \]
                Moreover, 
                \[
                NP = \bigcup_k \text{ NTIME }(n^k).
                \]
            </div>
            </p>
            </section>

            <section id="P=NP" class="section-content">
            <h2>P vs NP Question</h2>
            <p>
            <ul  style="padding-left: 40px;">
                <li>P is the class of languages for which membership can be <strong>decided</strong> in polynomial time.</li>
                <li>NP is the class of languages for which membership can be <strong>verified</strong> in polynomial time.</li>
            </ul>
            <br>
            We know the Hamiltonian cycle problem is in NP, but that are "not known" to be in P. Intuitively, it seems like polynomial 
            verifiability has greater power than polynomial decidability. However, it is still an open question whether there are problems 
            in NP that are not in P. In other words, we don't know if \(P = NP\) or \(P \neq NP\) mathematically.
            (So far, most researchers believe that the two classes are not equal.)
            <br><br>
            Currently, it is known that 
            \[
            NP \subseteq \text{ EXPTIME} = \bigcup_k \text{ TIME } (2^{n^k}).
            \]
            </p>
            </section>

            <section id="comp" class="section-content">
            <h2>NP-Completeness</h2>
            <p>
            It is known that the Hamiltonian cycle problem is said to be <strong>NP-complete</strong>. 
            (Proofs might be updated in the future.) 
            <div class="theorem">
                <span class="theorem-title"> NP-Completeness: </span>
                A language \(B\) is <strong>NP-complete</strong> if it satisfies following conditions:
                <ul  style="padding-left: 40px;">
                    <li>\(B\) is in NP.</li>
                    <li>Every \(A\) in NP is <strong>polynomial time reducible</strong> to \(B\).</li>
                </ul>
            </div>

            <div class="theorem">
                <span class="theorem-title"> Polynomial Time Reduction: </span>
            Language \(A\) is <strong>polynomial time reducible</strong> to language \(B\), denoted 
            \[
            A \leq_{P} B
            \]
            if a <strong>polynomial time computable function</strong> \(f: \Sigma^* \to \Sigma^*\) exists, where 
            \[
            \forall w, \, w \in A \Longleftrightarrow f(w) \in B.
            \]
            The function \(f\) is called the <strong>polynomial time reduction</strong> of \(A\) to \(B\).
            <br>
            Note: If \(f\) is a polynomial time computable function, there exists a polynomial time Turing machine \(M\) that halts 
            with \(f(w)\) in its tape, when started on any input (w). 
            </div>
            Finally, we introduce the Hamiltonian cycle problem with weighted edges. 
            <div class="proof">
                <span class="proof-title">Traveling Salesperson Problem (TSP), ver. Decision</span>
                    Given a set of cities, the distances between them, and a number \(k\), is there a tour that visits each 
                    city exactly once, returns to the starting city, and has total distance \(\leq k\)? 
            </div>
            This decision version problem is NP-complete, but the <strong>optimization</strong> version - which asks for the <strong>shortest</strong> 
            possible Hamiltonian cycle given edge weights - is <strong>NOT</strong> NP-complete, and it is considered as <strong>NP-hard</strong>.
            <br>
            Assume that \(P \neq NP\), then we have the following diagram about time complexity classes.
            <br>
            <div style="text-align: center;">
                <img src="Images/complexity.jpg" alt="complexity"  class="responsive-image">
            </div>
            Note: If \(P = NP\), then \(P = NP = NP\text{-complete}\).
            </p>
            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>