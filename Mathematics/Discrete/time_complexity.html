<!DOCTYPE html>
<html>
    <head> 
        <title>Time Complexity</title>
        <link rel="stylesheet" href="../styles.css">
        <script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="https://cdn.jsdelivr.net/pyodide/v0.23.3/full/pyodide.js"></script>
        <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body> 
        <div class="toc-container">
            <h2>Contents</h2>
            <ul>
                <li><a href="#intro">Time Conmlexity</a></li>
                <li><a href="#class">Time Complexity Classes</a></li>
                <li><a href="#"></a></li>
            </ul>
        </div>

        <h1 id="intro">Time Conmlexity</h1>
        <blockquote>
            Even if a problem is computationally solvable "in theory," it may not be solvable "in practice" if the solution requires 
            an excessive amount of time (or memory space, etc.). 
            <br><br>
            Let \(M\) be a deterministic Turing machine that halts on all inputs. The <strong>time complexity(running time)</strong> of \(M\) is 
            the function \(f: \mathbb{N} \to \mathbb{N}\), where \(f(n)\) is the maximum number of steps that \(M\) uses on any input 
            of length \(n\). We say that \(M\) runs in time \(f(n)\).
            <br>
            Usually we are interested in the running time of the algorithm for large inputs, and onsider only the highest order 
            term of the expression for the running time. This is called <strong>asymptotic analysis</strong>.
            <br><br>
            <div class="theorem">
                <span class="theorem-title">Big-O notation: </span>
                Let \(f\) and \(g\) be functions \(f, g: \mathbb{N} \to \mathbb{R}^+\). Say that 
                \[
                f(n) = O (g(n))
                \]
                if positive integers \(c\) and \(n_0\) exist such that for every integer \(n \geq n_0\),
                \[
                f(n) \leq c \, g(n).
                \]
                We say that \(g(n)\) is an <strong>asymptotic upper bound</strong> for \(f(n)\).
            </div>
            For example, consider \(f(n) = 3n^3 + 2n^2 + n + 5\). The highest order term is \(3n^3\). So, 
            we can say \(f(n) = O(n^3)\) with \(c = 11\), and \(n_0 = 1\).
            <br>
            (Check: \(f(n) \leq 3n^3 + 2n^3 + n^3 + 5n^3\))
            <div class="theorem">
                <span class="theorem-title">Little-o notation: </span>
                Let \(f\) and \(g\) be functions \(f, g: \mathbb{N} \to \mathbb{R}^+\). Say that 
                \[
                f(n) = o (g(n))
                \]
                if 
                \[
                \lim_{n \to \infty} \frac{|f(n)|}{|g(n)|} = 0.
                \]
                Equivalently, for any real number \(c >0\), a number \(n_0\) exists where 
                \[
                \forall n \geq n_0, \, f(n) < c \, g(n).
                \]
            </div>
            Little-o notation is used when we want to express that one function grows strictly slower than another, whereas big-O 
            notation merely provides a (not necessarily tight) upper bound.
        </blockquote>

        <h1 id="class">Time Complexity Classes</h1>
        <blockquote>
            Let \(t: \mathbb{N} \to \mathbb{R}^+\) be a function. Define the <strong>time complexity class</strong>, 
            \(\text{ TIME}(t(n))\), to be the collection of all languages that are decidable by an \(O(t(n))\) time Turing machine.
            <br><br>
            Consider the Turing machine algoithm, \(M_1\) for the language:  
            \[
            A = \{0^k 1^k | k \geq 0\}.
            \]
            We define \(M_1\) as follows: 
            <br>
            On input string \(w\):
            <ol>
                <li>Scan across the tape and reject if a 0 is found to the right of a 1.</li>
                <li>Repeat if both 0s and 1s remain on the tape.</li>
                <li>Scan across the tape, crossing off a single 0 and a single 1.</li>
                <li>If 0s(1s) still remain after all the 1s(0s) have been crossed off, reject. Otherwise, if neither 
                    0s nor 1s remain on the tape, accept. </li>
            </ol>
            The sample code for \(M_1\) is as follows: 
            <div class="collapsible-section">
                <button class="collapsible-btn">Show/Hide Code</button>
                <div class="collapsible-content">
                <pre class="python-code">
                    # Accept all strings generated from the language A = {0^k 1^k | k >= 0}
                    def machine1(w):
                        tape = list(w)
                        
                        # Scan the tape and reject if a 0 is found to the right of a 1. : O(n)
                        seen_one = False
                        for c in tape:
                            if c == '1':
                                seen_one = True
                            elif c == '0' and seen_one:  # a 0 appears after a 1.
                                return False

                        # Repeatedly cross off one 0 and one 1 as long as both are present. : O(n^2)
                        while '0' in tape and '1' in tape:
                            # Find the first uncrossed 0 and mark it.
                            idx0 = tape.index('0')
                            tape[idx0] = 'X'
                            
                            # Find the first uncrossed 1 and mark it.
                            idx1 = tape.index('1')
                            tape[idx1] = 'X'
                        
                        # If there are any uncrossed 0s or 1s remaining, reject the input. : O(n)
                        if '0' in tape or '1' in tape:
                            return False
                        # Otherwise, accept the input.
                        return True

                    if __name__ == "__main__":
                        # Test cases
                        test_cases = [
                            ("", True), ("0011", True), ("0", False), ("0101", False), ("001", False), ("011", False),
                            ("1100", False),  ("0000011111", True),  ("01", True), ("1111", False)
                        ]
                        for inp, expected in test_cases:
                            result = machine1(inp)
                            print(f"({inp!r}) = {result} (expected: {expected})")
                </pre>
            </div>
            <button class="run-button" onclick="runPythonCode()">Run Code</button>
            <div class="python-output" id="output"></div>
            <br>
            The running time is 
            \[
            O(n) + \frac{n}{2}O(n) + O(n) = O(n^2). 
            \]
            Then we can say that \(A \in \text{ TIME}(n^2)\). This class contains all languages that can be decided in 
            \(O(n^2)\) time.
            <br><br>
            We can improve \(M_1\). We define \(M_2\) as follows: 
            <br>
            On input string \(w\):
            <ol>
                <li>Scan across the tape and reject if a 0 is found to the right of a 1.</li>
                <li>Repeat if some 0s and some 1s remain on the tape.</li>
                <li>Scan across the tape, checking whether the total number of 0s and 1s remaining is even or odd. If it is odd, reject.</li>
                <li>Scan again across the tape, crossing off every other 0 starting with the first 0, and then crossing off every other 1 starting with the first 1.</li>
                <li>If no 0s and no 1s remain on the tape accept. Otherwise, reject.</li>
            </ol>
            \(M_2\) has time complexity \(O(n) + (1 + \log n )O(n) + O(n) = O(n \log n)\). Moreover, if we introduce another tape, 
            time complexity becomes \(O(n)), linear time. The following code demonstrate actual runnning times of \(M_2\) and the 
            <strong>two-tape Turing machine</strong>, \(M_3\).
            <div class="collapsible-section">
                <button class="collapsible-btn">Show/Hide Code</button>
                <div class="collapsible-content">
                <pre class="python-code">
                    import time

                    # Accept all strings generated from the language A = {0^k 1^k | k >= 0} with O(n log n)
                    def machine2(w):
                        tape = list(w)

                        # Reject if a 0 is found to the right of a 1.
                        seen_one = False
                        for ch in tape:
                            if ch == '1':
                                seen_one = True
                            elif ch == '0' and seen_one:
                                print("Invalid order: found a 0 after a 1.")
                                return False

                        # Build lists of indices for uncrossed 0s and 1s.
                        zero_indices = [i for i, ch in enumerate(w) if ch == '0']
                        one_indices = [i for i, ch in enumerate(w) if ch == '1']

                        # Repeat as long as both 0s and 1s remain.
                        while zero_indices and one_indices:
                            # Check whether the total remaining is even.
                            total_remaining = len(zero_indices) + len(one_indices)
                            if total_remaining % 2 != 0:
                                return False

                            # Cross off every other 0 starting with the first 0.
                            zero_indices = zero_indices[1::2]  # This "removes" every other 0.
                            
                            # Cross off every other 1 starting with the first 1.
                            one_indices = one_indices[1::2]

                        # Accept if both lists are empty.
                        if zero_indices or one_indices:
                            return False
                        return True

                    # Two-tape Turing machine: O(n)
                    def machine3(w):
                        tape1 = list(w)
                        tape2 = [None] * len(w)  # Pre-allocated tape2 for 0s only
                        tape2_index = 0  # Points to the current "end" of tape2

                        # Ensure all 0s precede 1s, copy 0s to tape2.
                        i = 0
                        while i < len(tape1):
                            if tape1[i] == '0':
                                tape2[tape2_index] = '0'
                                tape2_index += 1
                            elif tape1[i] == '1':
                                break
                            else:
                                return False  # Invalid character
                            i += 1

                        # Match each 1 with a 0 from tape2.
                        while i < len(tape1):
                            if tape1[i] == '1':
                                if tape2_index == 0:
                                    return False  # No 0 to match
                                tape2_index -= 1  # "Pop" from tape2 (backward)
                            elif tape1[i] == '0':
                                return False  # Found a 0 after 1 — invalid order
                            else:
                                return False  # Invalid character
                            i += 1

                        return tape2_index == 0  # All 0s matched

                    # In this case, accepted strings often cause the worst-case performance
                    # because they force the algorithm to do full verification.
                    def worst_case_input(n):
                        print("Length: ", n)
                        return "0" * n + "1" * n

                    if __name__ == "__main__":
                        
                        # Define the length of the string. Here, n = 10,000,000
                        input_str = worst_case_input(10000000)

                        # Measure machine 2: (O(n log n))
                        start = time.time()
                        machine2(input_str)
                        end = time.time()
                        print("Machine2 (O(n log n)) took:", end - start, "seconds")
                        
                        # Measure machine 3: (O(n))
                        start = time.time()
                        machine3(input_str)
                        end = time.time()
                        print("Machine3 (O(n)) took:", end - start, "seconds")
                </pre>
            </div>
            <button class="run-button" onclick="runPythonCode()">Run Code</button>
            <div class="python-output" id="output"></div>
            <br>
            In computability theory, \(M_1\), \(M_2\), and \(M_3\) are all equivalent, but in complexity theory, 
            the choice of model affects the time complexity of languages. In practice, it is hard to say that \(M_1\) and \(M_3\)
            are the "same." In the code, we set  \(n = 10,000,000\), which is too large for |(M_1\) that has time complexity \(O(n^2)\).
            <br><br>
            Note: Depending on the implementation, practical runtimes can be worse than what theoretical complexities suggest. 
            High-level languages such as Python often widen the gap between theoretical complexity and practical runtime. 
            Often Python code runs slower than compiled languages like C.  
        </blockquote>

        <h1 id=""></h1>
        <blockquote>
        </blockquote>

        <a href="../../index.html">Back to Home </a>
        <br> <a href="discrete_math.html">Back to Discrete Mathematics & Algorithms</a>

        <script src="../runPythonCode.js"></script>
        <script src="../collapsible.js"></script>
        </body>
    </html>