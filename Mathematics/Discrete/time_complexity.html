<!DOCTYPE html>
<html>
    <head> 
        <title>Time Complexity</title>
        <link rel="stylesheet" href="../styles.css">
        <script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="https://cdn.jsdelivr.net/pyodide/v0.23.3/full/pyodide.js"></script>
        <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body> 
        <div class="toc-container">
            <h2>Contents</h2>
            <ul>
                <li><a href="#intro">Time Conmlexity</a></li>
                <li><a href="#class">Time Complexity Classes</a></li>
                <li><a href="#"></a></li>
            </ul>
        </div>

        <h1 id="intro">Time Conmlexity</h1>
        <blockquote>
            Even if a problem is computationally solvable "in theory," it may not be solvable "in practice" if the solution requires 
            an excessive amount of time (or memory space, etc.). 
            <br><br>
            Let \(M\) be a deterministic Turing machine that halts on all inputs. The <strong>time complexity(running time)</strong> of \(M\) is 
            the function \(f: \mathbb{N} \to \mathbb{N}\), where \(f(n)\) is the maximum number of steps that \(M\) uses on any input 
            of length \(n\). We say that \(M\) runs in time \(f(n)\).
            <br>
            Usually we are interested in the running time of the algorithm for large inputs, and onsider only the highest order 
            term of the expression for the running time. This is called <strong>asymptotic analysis</strong>.
            <br><br>
            <div class="theorem">
                <span class="theorem-title">Big-O notation: </span>
                Let \(f\) and \(g\) be functions \(f, g: \mathbb{N} \to \mathbb{R}^+\). Say that 
                \[
                f(n) = O (g(n))
                \]
                if positive integers \(c\) and \(n_0\) exist such that for every integer \(n \geq n_0\),
                \[
                f(n) \leq c \, g(n).
                \]
                We say that \(g(n)\) is an <strong>asymptotic upper bound</strong> for \(f(n)\).
            </div>
            For example, consider \(f(n) = 3n^3 + 2n^2 + n + 5\). The highest order term is \(3n^3\). So, 
            we can say \(f(n) = O(n^3)\) with \(c = 11\), and \(n_0 = 1\).
            <br>
            (Check: \(f(n) \leq 3n^3 + 2n^3 + n^3 + 5n^3\))
            <div class="theorem">
                <span class="theorem-title">Little-o notation: </span>
                Let \(f\) and \(g\) be functions \(f, g: \mathbb{N} \to \mathbb{R}^+\). Say that 
                \[
                f(n) = o (g(n))
                \]
                if 
                \[
                \lim_{n \to \infty} \frac{|f(n)|}{|g(n)|} = 0.
                \]
                Equivalently, for any real number \(c >0\), a number \(n_0\) exists where 
                \[
                \forall n \geq n_0, \, f(n) < c \, g(n).
                \]
            </div>
            Little-o notation is used when we want to express that one function grows strictly slower than another, whereas big-O 
            notation merely provides a (not necessarily tight) upper bound.
        </blockquote>

        <h1 id="class">Time Complexity Classes</h1>
        <blockquote>
            Let \(t: \mathbb{N} \to \mathbb{R}^+\) be a function. Define the <strong>time complexity class</strong>, 
            \(\text{ TIME}(t(n))\), to be the collection of all languages that are decidable by an \(O(t(n))\) time Turing machine.
            <br><br>
            Consider the Turing machine algoithm, \(M_1\) for the language:  
            \[
            A = \{0^k 1^k | k \geq 0\}.
            \]
            We define \(M_1\) as follows: 
            <br>
            On input string \(w\):
            <ol>
                <li>Scan across the tape and reject if a 0 is found to the right of a 1.</li>
                <li>Repeat if both 0s and 1s remain on the tape.</li>
                <li>Scan across the tape, crossing off a single 0 and a single 1.</li>
                <li>If 0s(1s) still remain after all the 1s(0s) have been crossed off, reject. Otherwise, if neither 
                    0s nor 1s remain on the tape, accept. </li>
            </ol>
            The sample code for \(M_1\) is as follows: 
            <div class="collapsible-section">
                <button class="collapsible-btn">Show/Hide Code</button>
                <div class="collapsible-content">
                <pre class="python-code">
                    # Accept all strings generated from the language A = {0^k 1^k | k >= 0}
                    def machine1(w):
                        tape = list(w)
                        
                        # Scan the tape and reject if a 0 is found to the right of a 1. : O(n)
                        seen_one = False
                        for c in tape:
                            if c == '1':
                                seen_one = True
                            elif c == '0' and seen_one:  # a 0 appears after a 1.
                                return False

                        # Repeatedly cross off one 0 and one 1 as long as both are present. : O(n^2)
                        while '0' in tape and '1' in tape:
                            # Find the first uncrossed 0 and mark it.
                            idx0 = tape.index('0')
                            tape[idx0] = 'X'
                            
                            # Find the first uncrossed 1 and mark it.
                            idx1 = tape.index('1')
                            tape[idx1] = 'X'
                        
                        # If there are any uncrossed 0s or 1s remaining, reject the input. : O(n)
                        if '0' in tape or '1' in tape:
                            return False
                        # Otherwise, accept the input.
                        return True

                    if __name__ == "__main__":
                        # Test cases
                        test_cases = [
                            ("", True), ("0011", True), ("0", False), ("0101", False), ("001", False), ("011", False),
                            ("1100", False),  ("0000011111", True),  ("01", True), ("1111", False)
                        ]
                        for inp, expected in test_cases:
                            result = machine1(inp)
                            print(f"({inp!r}) = {result} (expected: {expected})")
                </pre>
            </div>
            <button class="run-button" onclick="runPythonCode()">Run Code</button>
            <div class="python-output" id="output"></div>
            <br>
            The runrunning time is 
            \[
            O(n) + \frac{n}{2}O(n) + O(n) = \(O(n^2)\). 
            \]
            Then we can say that \(A \in \text{ TIME}(n^2)\). This class contains all languages that can be decided in 
            \(O(n^2)\) time.
        </blockquote>

        <h1 id=""></h1>
        <blockquote>
        </blockquote>

        <a href="../../index.html">Back to Home </a>
        <br> <a href="discrete_math.html">Back to Discrete Mathematics & Algorithms</a>

        <script src="../runPythonCode.js"></script>
        <script src="../collapsible.js"></script>
        </body>
    </html>