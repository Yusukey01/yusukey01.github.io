---
layout: default
title: Intro to Theory of Computation
level: detail
topic_id: disc-3
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body>
        {% include learning_resource_schema.html topic_id=page.topic_id %}
       
        <div class="hero-section">
            <h1 class="webpage-name">Intro to Theory of Computation</h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#intro">Introduction</a>
            <a href="#fa_rl">Finite Automata & Regular Languages</a>
            <a href="#regular_op">Regular Operations</a>
            <a href="#dfa">Deterministic & Nondeterministic Machine</a>
            <a href="#r_exp">Regular Expressions</a>
        </div> 

        <div class="container">  
           
            <section id="intro" class="section-content">
                <h2>Introduction</h2>
                <p>
                    <strong>Automata theory</strong> is a foundational area of theoretical computer science and discrete mathematics that studies abstract 
                    machines and computational problems. It provides a rigorous framework for understanding <strong>formal languages</strong>, state-based 
                    computation, and algorithmic processes. For instance, automata theory is essential in compiler design, natural language processing, 
                    software verification, and the study of complexity classes in the <strong>theory of computation</strong>. By exploring automata theory, we 
                    will develop a deeper understanding of computation, logic, and the mathematical principles governing algorithmic processes.
                </p>

                <p>
                    In this page, we introduce the simplest computational model — the <strong>finite automaton</strong> - 
                    and the class of languages it recognizes: <strong>regular languages</strong>. We then study the regular 
                    operations (union, concatenation, and Kleene star), the equivalence between deterministic and nondeterministic 
                    machines, and the connection to <strong>regular expressions</strong>.
                </p>
            </section>

            <section id="fa_rl" class="section-content">
                <h2>Finite Automata & Regular Languages</h2>
                <p>
                    Real computers are enormously complex, so to study the fundamental principles of computation, we introduce 
                    simplified <strong>computational models</strong> that isolate specific features. The simplest such model 
                    is the <strong>finite automaton</strong> (also called a <strong>finite state machine</strong>).
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Finite Automaton (DFA)</span>
                    <p>
                        A <strong>finite automaton</strong> is a 5-tuple \((Q, \Sigma, \delta, q_0, F)\) where
                    </p>
                    <ul style="padding-left: 40px;">
                        <li>\(Q\) is a finite set called the <strong>states</strong>,</li>
                        <li>\(\Sigma\) is a finite set called the <strong>alphabet</strong>,</li>
                        <li>\(\delta: Q \times \Sigma \to Q\) is the <strong>transition function</strong>,</li>
                        <li>\(q_0 \in Q\) is the <strong>start state</strong>,</li>
                        <li>\(F \subseteq Q\) is the set of <strong>accept states</strong>.</li>
                    </ul>
                </div>

                <p>
                    Let \(A\) be the set of all strings that machine \(M\) accepts. We say that \(A\) is the <strong>language</strong> of 
                    machine \(M\) and write:
                    \[
                    L(M) = A 
                    \]
                    We also say that \(M\) <strong>recognizes</strong> \(A\). Moreover, a language is called a <strong>regular language</strong> if 
                    some finite automaton recognizes it.
                </p>
                <p>
                    Consider the following finite automaton. 
                </p>
                <div style="text-align: center;">
                    <img src="Images/DFA_example1.jpg" alt="Finite automata"  class="responsive-image">
                </div> 
                <p>
                    First, this directed multigraph is called the <strong>state diagram</strong> of the finite automaton.
                    It has three states, \(Q = \{q_0, q_1, q_2\}\), where \(q_0\) is the start state, and \(F = \{q_1\}\) is the 
                    accept state which is denoted by a double circle. The arrows are transitions \(\delta\) from one state to another state.
                    This automaton processes an input string over the alphabet (in this case, \(\Sigma = \{0, 1\}\)) and returns either 
                    "accept" or "reject" as output.
                </p>
                <p>
                    For example, if input string is \(1101101\), this automaton processes the string as follows: 
                </p>

                <div style="padding-left: 40px;">
                    &emsp;&emsp;&emsp;Start reading
                    <br>
                    &emsp;&emsp;&emsp;Read 1, move from \(q_0\) to \(q_1\)
                    <br>
                    &emsp;&emsp;&emsp;Read 1, stay in \(q_1\)
                    <br>
                    &emsp;&emsp;&emsp;Read 0, move to \(q_2\)
                    <br>
                    &emsp;&emsp;&emsp;Read 1, move to \(q_1\)
                    <br>
                    &emsp;&emsp;&emsp;Read 1, stay in \(q_1\)
                    <br>
                    &emsp;&emsp;&emsp;Read 0, move to \(q_2\)
                    <br>
                    &emsp;&emsp;&emsp;Read 1, move to \(q_1\)
                    <br>
                    &emsp;&emsp;&emsp;End reading 
                    <br>
                    &emsp;&emsp;&emsp;Return "accept." 
                </div>
                <p>
                    This automaton recognizes strings that end with a 1 followed by an even number of 0s. For example, "10100" is 
                    accepted because it ends with 1 followed by two 0s, but "1011000" is rejected because it ends with three 0s after 
                    the last 1. Note that a string ending in 1 (with zero trailing 0s) is also accepted, since zero is even.
                </p>
            </section>

            <section id="regular_op" class="section-content">
                <h2>Regular Operations</h2>

                <p>
                    We now define three fundamental operations on languages. A key result is that regular languages are 
                    <em>closed</em> under all three - applying any of these operations to regular languages always yields 
                    another regular language.
                </p>
               
                <div class="theorem">
                    <span class="theorem-title">Definition: Regular Operations</span>
                    <p>
                        Let \(A\) and \(B\) be languages over an alphabet \(\Sigma\).
                    </p>
                    <ul style="padding-left: 40px;">
                        <li><strong>Union</strong>:<br>
                            \(A \cup B = \{x \mid x \in A \text{ or } x \in B\}\)
                        </li>
                        <li><strong>Concatenation</strong>:<br>
                            \(A \circ B = \{xy \mid x \in A \text{ and } y \in B\}\)<br>
                            Note: \(\emptyset \circ A = \emptyset\), and \(\{\epsilon\} \circ A = A\). 
                            Also, \(A \circ A = A^2\), and we define \(A^0 = \{\epsilon\}\).
                        </li>
                        <li><strong>Kleene Star</strong>:<br>
                            \(A^* = \{x_1 x_2 \cdots x_k \mid k \geq 0 \text{ and each } x_i \in A\}\)<br>
                            Equivalently, \(A^* = A^0 \cup A^1 \cup A^2 \cup \cdots\).<br>
                            Note: The empty string \(\epsilon\) is always in \(A^*\) (the case \(k = 0\)). 
                            In particular, \(\emptyset^* = \{\epsilon\}\) 
                            since \(\emptyset^* = \emptyset^0 \cup \emptyset^1 \cup \emptyset^2 \cup \cdots\).
                        </li>
                    </ul>
                </div>

                <p>
                    For example, Let \(\Sigma = \{a, \, b, \, c, \, \cdots, \, x, \, y, \, z\}\). 
                    If \(A = \{black, \, white\}\) and \(B = \{dog,  \, cat\}\), then 
                    \[
                    \begin{align*}
                    &A \cup B = \{black, \, white, \, dog,  \, cat \} \\\\
                    &A \circ B  = \{blackdog, \, blackcat, \, whitedog, \, whitecat\} \\\\
                    &A^* = \{\epsilon, \, black, \, white, \, blackblack, \, blackwhite, \, whiteblack, \, whitewhite, \, blackblackblack, \, blackblackwhite, \,\ \cdots\}
                    \end{align*}
                    \]
                </p>

                <div class="theorem">
                    <span class="theorem-title">Theorem 1: Closure of Regular Languages</span>
                    <p>
                        The class of regular languages is closed under the regular operations. That is, 
                        if \(A\) and \(B\) are regular languages, then \(A \cup B\), \(A \circ B\), 
                        \(A^*\), and \(B^*\) are also regular.
                    </p>
                </div>
               
                <div class="proof">
                    <span class="proof-title">Proof: Closure under union</span> 
                    <p>
                        Suppose we have two finite automata
                        \[
                        M_1 = (Q_1, \Sigma, \delta_1, q_{0_1}, F_1)
                        \]
                        and
                        \[
                        M_2 = (Q_2, \Sigma, \delta_2, q_{0_2}, F_2).
                        \]
                        These can recognize regular languages \(A_1\) and \(A_2\) respectively. 
                    </p>
                    <p>
                        Here, we can <strong>construct</strong> \(M_3\) to recognize \(A_1 \cup A_2\) as follows:
                        \[
                        M_3 = (Q_3, \Sigma, \delta_3, q_{0_3}, F_3)
                        \]
                        where 
                        \[
                        Q_3 = Q_1 \times Q_2 = \{(q_1, q_2)\, | \, q_1 \in Q_1 \text{ and } q_2 \in Q_2\}
                        \]
                    </p>
                    <p>
                        \[
                        \delta_3((q_1, q_2), a) = (\delta_1(q_1, a), \delta_2(q_2, a)) \quad \forall a \in  \Sigma
                        \]
                    </p>
                    <p>
                        \[
                        q_{0_3} = (q_{0_1}, q_{0_2})
                        \]
                    </p>
                    <p>
                        \[
                        F_3 = \{(q_1, q_2) \,| \, q_1 \in F_1 \text{ or } q_2 \in F_2 \}
                        \] 
                        which is the same as \((F_1 \times Q_2) \cup (Q_1 \times F_2)\).
                    </p>
                </div>
                <p>
                    Note: If we say \(F_3 = F_1 \times F_2\), the resulting language is the <strong>intersection</strong>. Actually, the class of 
                    regular languages is closed under intersection too. 
                </p>
            </section>

            <section id="dfa" class="section-content">
                <h2>Deterministic & Nondeterministic Machine</h2>
                
                <p>
                    So far, we have considered <strong>deterministic</strong> computation: at each step, the current state and input 
                    symbol uniquely determine the next state. However, what if a computation is allowed multiple choices for the 
                    next state? Such a computation is called <strong>nondeterministic</strong>. Every deterministic finite automaton 
                    (<strong>DFA</strong>) is trivially a nondeterministic finite automaton (<strong>NFA</strong>), since determinism 
                    is a special case of nondeterminism.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Nondeterministic Finite Automaton (NFA)</span>
                    <p>
                        A <strong>nondeterministic finite automaton</strong> is a 5-tuple \((Q, \Sigma, \delta, q_0, F)\) where
                    </p>
                    <ul style="padding-left: 40px;">
                        <li>\(Q\) is a finite set of states,</li>
                        <li>\(\Sigma\) is a finite alphabet,</li>
                        <li>\(\delta: Q \times \Sigma_{\epsilon} \to \mathcal{P}(Q)\) is the transition function,</li>
                        <li>\(q_0 \in Q\) is the start state,</li>
                        <li>\(F \subseteq Q\) is the set of accept states,</li>
                    </ul>
                    <p>
                        where \(\Sigma_{\epsilon} = \Sigma \cup \{\epsilon\}\) and \(\mathcal{P}(Q)\) is the <strong>power set</strong> of \(Q\).
                    </p>
                </div>

                <p>
                    Note: The power set of a set is the set of all possible subsets of that set, including the empty set and the set itself. For example, 
                    if \(Q = \{a, b, c\}\), then \(\mathcal{P}(Q) = \{\emptyset, \{a\}, \{b\}, \{c\}, \{a, b\}, \{a, c\}, \{b, c\}, \{a, b, c\}\} \). So, if 
                    a set has \(n\) elements, its power set has \(2^n\) elements. 
                </p>

                <p>
                    At each state, the NFA can split itself into multiple branches and keeps following all the possible branches in parallel. 
                    In other words, the NFA can have multiple active states at once, while the DFA always has a single active state. 
                    If at least one of these branches reaches an accept state, then the whole computation accepts.
                </p>

                <p>
                    Note: The NFA sounds like parallel computation, but in "actual" parallel computation, multiple processors or threads execute 
                    tasks concurrently, often with considerations for synchronization, communication, and resource sharing. NFAs don't model 
                    these practical concerns. 
                </p>

                <div class="theorem">
                    <span class="theorem-title">Theorem 2: NFA-DFA Equivalence</span>
                    <p>
                        Every NFA has an equivalent DFA. That is, for every NFA \(N\), there exists a DFA \(D\) 
                        such that \(L(N) = L(D)\).
                    </p>
                </div>

                <p>  
                    Importantly, this theorem says that NFAs and DFAs recognize <strong>the same class of languages</strong> - the 
                    regular languages. However, an NFA is often much smaller and easier to design than its equivalent DFA. The 
                    conversion (known as the <strong>power set construction</strong> or <strong>subset construction</strong>) can 
                    produce a DFA with up to \(2^{|Q|}\) states, so the two models are not equivalent in terms of succinctness.
                </p>
                <p>
                    We now introduce a third way to describe regular languages - through algebraic expressions rather than machines.
                </p>

            </section>

            <section id="r_exp" class="section-content">
                <h2>Regular Expressions</h2>

                <div class="theorem">
                    <span class="theorem-title">Definition: Regular Expression</span>
                    <p>
                        \(R\) is a <strong>regular expression</strong> over the alphabet \(\Sigma\) if \(R\) is one of the following:
                    </p>
                    <ol style="padding-left: 40px;">
                        <li>\(a\) for some \(a \in \Sigma\) &ensp;(the language \(\{a\}\)),</li>
                        <li>\(\epsilon\) &ensp;(the language \(\{\epsilon\}\) containing only the empty string),</li>
                        <li>\(\emptyset\) &ensp;(the empty language, containing no strings),</li>
                        <li>\((R_1 \cup R_2)\), where \(R_1\) and \(R_2\) are regular expressions,</li>
                        <li>\((R_1 \circ R_2)\), where \(R_1\) and \(R_2\) are regular expressions,</li>
                        <li>\((R_1^*)\), where \(R_1\) is a regular expression.</li>
                    </ol>
                    <p>
                        This is an <strong>inductive definition</strong>: cases 4-6 build larger expressions from smaller ones.
                    </p>
                </div>

                <p>
                    A language that can be described by a regular expression is precisely a language recognizable by a 
                    finite automaton — this is the reason such languages are called <strong>regular</strong>. 
                    To distinguish a regular expression \(R\) from the language it describes, we write \(L(R)\) for 
                    the language of \(R\).
                </p>

                <div class="theorem">
                    <span class="theorem-title">Theorem 3: Equivalence of Regular Expressions and Finite Automata</span>
                    <p>
                        A language is regular if and only if some regular expression describes it. That is:
                    </p>
                    <ol style="padding-left: 40px;">
                        <li>If a language is described by a regular expression, then it is regular.</li>
                        <li>If a language is regular, then it is described by a regular expression.</li>
                    </ol>
                </div>

                <div class="proof">
                    <span class="proof-title">Proof: Part 1</span> 
                    <p>
                        For each case in the definition, we want to convert regular expression \(R\) into NFA \(M\) recognizing some 
                        language because we know that if an NFA recognizes the language, then it is regular. 
                    </p>
                    <ol style="padding-left: 40px;">
                        <li>\(R = a\) for some \(a \in \Sigma\):<br>
                            Then 
                            \[
                            L(R) = \{a\}
                            \]
                            and the following NFA recognizes \(L(R)\):
                            \[
                            M = (\{q_0 , q_1\}, \Sigma, \delta, q_0, \{q_1\})
                            \]
                            where \(\delta(q_0, a) = \{q_1\}\) and \(\delta(r, b) = \emptyset\) for \(r \neq q_0\) or \(b \neq a\).
                        </li>
                        <li>\(R =\epsilon\):<br>
                            Then
                            \[
                            L(R) = \{\epsilon\}
                            \]
                            and the following NFA recognizes \(L(R)\):
                            \[
                            M = (\{q_0\}, \Sigma, \delta, q_0, \{q_0\})
                            \]
                            where \(\delta(r, b) = \emptyset\) for any \(r\) and \(b\).
                        </li>
                        <li>\(R = \emptyset\):<br>
                            Then 
                            \[
                            L(R) = \emptyset
                            \]
                            and the following NFA recognizes \(L(R)\):
                            \[
                            M = (\{q\}, \Sigma, \delta, q, \emptyset)
                            \]
                            where \(\delta(r, b) = \emptyset\) for any \(r\) and \(b\).
                        </li>

                        <div style="text-align: center;">
                            <img src="Images/P1_case1_2_3.jpg" alt="Case 1, 2, and 3"  class="responsive-image">
                        </div>

                        <p>
                            For cases 4, 5, and 6, let \(M_1 = (Q_1, \Sigma, \delta_1, q_{0_1}, F_1)\) be an NFA that recognizes \(L(R_1)\) and 
                            \(M_2 = (Q_2, \Sigma, \delta_2, q_{0_2}, F_2)\) be an NFA that recognizes \(L(R_2)\). We assume that the state sets 
                            \(Q_1\) and \(Q_2\) are disjoint.
                        </p>

                        <li>\(R = (R_1 \cup R_2)\):<br>
                            Then
                            \[
                            L(R) = (R_1 \cup R_2)
                            \]
                            and the following NFA recognizes \(L(R)\):
                            \[
                            M = ( Q_1 \cup Q_2 \cup \{q_0\}, \Sigma, \delta, q_0, F_1 \cup F_2) 
                            \]
                            where for any \(q \in Q\) and any \(a \in \Sigma_{\epsilon}\),
                            \[
                            \delta(q, a) =  \begin{cases}
                                            \delta_1(q, a) &\text{if \(q \in Q_1\)}, \\

                                            \delta_2(q, a) &\text{if \(q \in Q_2\)}, \\

                                            \{q_{0_1}, q_{0_2}\} &\text{if \(q = q_0\) and \(a = \epsilon\)}, \\

                                            \emptyset  &\text{if \(q = q_0\) and \(a \neq \epsilon\)}. \\

                                            \end{cases}
                            \]
                        </li>
                        <div style="text-align: center;">
                            <img src="Images/P1_case4.jpg" alt="Case 4"  class="responsive-image">
                        </div>

                        <li>\(R = (R_1 \circ R_2)\):<br>
                            Then
                            \[
                            L(R) = (R_1 \circ R_2)
                            \]
                            and the following NFA recognizes \(L(R)\):
                            \[
                            M = ( Q_1 \cup Q_2 , \Sigma, \delta, q_{0_1}, F_2)
                            \]
                            where for any \(q \in Q\) and any \(a \in \Sigma_{\epsilon}\),
                            \[
                            \delta(q, a) =  \begin{cases}
                                            \delta_1(q, a) &\text{if \(q \in Q_1\) and \(q \not\in F_1\) }, \\
                                            \delta_1(q, a) &\text{if \(q \in F_1\) and \(a \neq \epsilon\) }, \\
                                            \delta_1(q, a) \cup \{q_{0_2}\} &\text{if \(q \in F_1\) and \(a = \epsilon\) } \\
                                            \delta_2(q, a) &\text{if \(q \in Q_2\) }. \\
                                        \end{cases}
                            \]
                        </li>
                        <div style="text-align: center;">
                            <img src="Images/P1_case5.jpg" alt="Case 5"  class="responsive-image">
                        </div>

                        <li>\(R = (R_1^*) \):<br>
                            Then
                            \[
                            L(R) = (R_1^*)
                            \]
                            and the following NFA recognizes \(L(R)\):
                            \[
                            M = ( Q_1 \cup \{q_0\}, \Sigma, \delta, q_0, \{q_0\} \cup F_1) 
                            \]
                            where for any \(q \in Q\) and any \(a \in \Sigma_{\epsilon}\),
                            \[
                            \delta(q, a) =  \begin{cases}
                                            \delta_1(q, a) &\text{if \(q \in Q_1\) and \(q \not\in F_1\) } \\
                                            \delta_1(q, a) &\text{if \(q \in F_1\) and \(a \neq \epsilon\) }, \\
                                            \delta_1(q, a) \cup \{q_{0_1}\} &\text{if \(q \in F_1\) and \(a = \epsilon\) }, \\
                                            \{q_{0_1}\} &\text{if \(q = q_0\) and \(a = \epsilon\) }, \\
                                            \emptyset &\text{if \(q=q_0\) and \(a \neq \epsilon\)}. \\
                                        \end{cases}
                            \]
                        </li>
                        <div style="text-align: center;">
                            <img src="Images/P1_case6.jpg" alt="Case 6"  class="responsive-image">
                        </div>
                    </ol>
                </div>
                <p>
                    As an example, we convert the regular expression \((01 \cup 1)^*\) into an NFA through a sequence of stages. This expression 
                    generates strings such as
                    \[
                    \{\epsilon, \, 01, \, 1, \, 0101, \, 11, \, 1101, \, 01011101, \, 11111, \, 01101011110111, \, \cdots\}
                    \] 
                    and the following NFA recognizes these strings. When the NFA follows an \(\epsilon\)-transition, it moves to the next state 
                    without reading the next symbol from the input string. 
                </p>
                
                <div style="text-align: center;">
                    <img src="Images/NFA_from_RE.jpg" alt="NFA from Regular Expression"  class="responsive-image">
                </div>
                
            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>
