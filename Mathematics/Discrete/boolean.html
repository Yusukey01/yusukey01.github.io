---
layout: default
title: Boolean Logic
topic_id: disc-4
level: detail
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body>
        {% include learning_resource_schema.html topic_id=page.topic_id %}
       
        <div class="hero-section">
            <h1 class="webpage-name">Boolean Logic</h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#bool">Boolean Logic</a>
            <a href="#negation">Negation of Conjunction & Disjunction</a>
            <a href="#circuit">Circuits</a>
        </div> 

        <div class="container">  
           
            <section id="bool" class="section-content">
                <h2>Boolean Logic</h2>
                <p>
                    In <strong>Boolean Logic</strong>, we can only use two valuses; <strong>TRUE</strong> and <strong>FALSE</strong>. 
                    This mathematical system is the foundation of digital electronics and computer design. Often we represent TRUE by 1 
                    and FALSE by 0, but this is just representation, technically, \(TRUE \neq 1\). 
                </p>

                <p>
                    Boolean values are combined using the following fundamental operations:
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Fundamental Boolean Operations</span>
                    <ul style="padding-left: 40px;">
                        <li><strong>Negation (NOT): \(\neg\)</strong><br>
                            The negation of a Boolean value is its opposite: 
                            \(\neg 1 = 0\) and \(\neg 0 = 1\).
                        </li>
                        <li><strong>Conjunction (AND): \(\wedge\)</strong><br>
                            The conjunction of two Boolean values is 1 if <strong>both</strong> operands are 1: 
                            \(1 \wedge 0 = 0,\; 1 \wedge 1 = 1,\; 0 \wedge 0 = 0\).
                        </li>
                        <li><strong>Disjunction (OR): \(\vee\)</strong><br>
                            The disjunction of two Boolean values is 1 if <strong>at least one</strong> operand is 1: 
                            \(1 \vee 0 = 1,\; 1 \vee 1 = 1,\; 0 \vee 0 = 0\).
                        </li>
                    </ul>
                </div>
               
                <p>
                    More Boolean operations:  
                </p>

                <ul style="padding-left: 40px;">
                    <li><strong>Exclusive Or (XOR): \(\oplus\)</strong><br>
                        XOR is 1 if exactly one of its two operands is 1: 
                        \(1 \oplus 1 = 0,\; 1 \oplus 0 = 1,\; 0 \oplus 0 = 0\).
                    </li>
                    <li><strong>Equality (XNOR): \(\leftrightarrow\)</strong><br> 
                        Equality is 1 if both operands have the same value: 
                        \(1 \leftrightarrow 1 = 1,\; 1 \leftrightarrow 0 = 0,\; 0 \leftrightarrow 0 = 1\). 
                        This is the logical complement of XOR.
                    </li>
                    <li><strong>Implication: \(\rightarrow\)</strong><br>
                        The implication \(P \rightarrow Q\) is 0 only when \(P = 1\) and \(Q = 0\); otherwise it is 1: 
                        \(1 \rightarrow 1 = 1,\; 1 \rightarrow 0 = 0,\; 0 \rightarrow 0 = 1\).
                    </li>
                </ul>
                
            </section>

            <section id="negation" class="section-content">
                <h2>Negation of Conjunction & Disjunction</h2>
                
                <div class="theorem">
                    <span class="theorem-title">Definition: NAND and NOR</span>
                    <ul style="padding-left: 40px;">
                        <li><strong>NAND: \(\uparrow\)</strong><br>
                            The negation of conjunction:
                            \[
                            P \uparrow Q = \neg(P \wedge Q).
                            \]
                            NAND is TRUE unless both \(P\) and \(Q\) are TRUE: 
                            \(1 \uparrow 1 = 0,\; 1 \uparrow 0 = 1,\; 0 \uparrow 1 = 1,\; 0 \uparrow 0 = 1\)
                        </li>
                        <li><strong>NOR: \(\downarrow\)</strong><br> 
                            The negation of disjunction:
                            \[
                            P \downarrow Q = \neg(P \vee Q).
                            \]
                            NOR is TRUE only when both \(P\) and \(Q\) are FALSE: 
                            \(1 \downarrow 1 = 0,\; 1 \downarrow 0 = 0,\; 0 \downarrow 1 = 0,\; 0 \downarrow 0 = 1\).
                        </li>
                    </ul>
                </div>

                <div class="theorem">
                    <span class="theorem-title">Definition: Functional Completeness</span>
                    <p>
                        A set of Boolean operations is <strong>functionally complete</strong> if every Boolean function 
                        can be expressed using only operations from that set.
                    </p>
                </div>

                <p>
                    Remarkably, both \(\{\uparrow\}\) (NAND alone) and \(\{\downarrow\}\) (NOR alone) are functionally 
                    complete. This means that any Boolean circuit can be built from a single type of gate - a fact 
                    exploited in hardware design, where NAND-based logic dominates CPU and memory circuits. 
                    We demonstrate this for NAND below.
                </p>

                <div class="proof">
                    <span class="proof-title">NAND is Functionally Complete</span>
                    <p>Every fundamental operation can be expressed using only NAND:</p>
                    <ul style="padding-left: 40px;">
                        <li><strong>NOT:</strong> \(\quad \neg P = P \uparrow P\)</li>
                        <li><strong>AND:</strong> \(\quad P \wedge Q = (P \uparrow Q) \uparrow (P \uparrow Q)\)</li>
                        <li><strong>OR:</strong> \(\quad P \vee Q = (P \uparrow P) \uparrow (Q \uparrow Q)\)</li>
                    </ul>
                    <p>
                        Since AND, OR, and NOT can express any Boolean function, and all three can be built from NAND alone, 
                        NAND is functionally complete.
                    </p>
                </div>

                <p>
                    Since every Boolean operation can be written in terms of AND, OR, and NOT, it follows that 
                    every Boolean operation can be expressed using NAND alone. For example:
                </p>

                <ul style="padding-left: 40px;">
                    <li><strong>Implication:</strong><br>
                        \[
                        P \rightarrow Q = \neg P \vee Q = P \uparrow (Q \uparrow Q)
                        \]
                    </li>
                    <li><strong>XOR:</strong><br>
                        The standard 4-NAND gate construction is
                        \[
                        P \oplus Q = (P \uparrow (P \uparrow Q)) \uparrow (Q \uparrow (P \uparrow Q))
                        \]
                    </li>
                    <li><strong>Equality (XNOR):</strong><br> 
                        Since \(P \leftrightarrow Q = \neg(P \oplus Q)\), we negate the XOR construction above: 
                        let \(R = (P \uparrow (P \uparrow Q)) \uparrow (Q \uparrow (P \uparrow Q))\), then 
                        \(P \leftrightarrow Q = R \uparrow R\), using 5 NAND gates total.
                    </li>
                </ul>
                
            </section>

            <section id="circuit" class="section-content">
                <h2>Circuits</h2>
                <p>
                    When we study Boolean logic as a purely mathematical system, the focus is on abstract algebraic properties. However, 
                    when these Boolean functions are implemented in hardware, they are called <strong>logic gates</strong>.
                    Computers are built using electronic components wired together in a design known as a <strong>digital circuit</strong>. Logic 
                    gates are physically implemented using transistors, and each Boolean operation corresponds to a type of gate that controls the 
                    flow of electrical signals.
                </p>
                <p>
                    However, circuits are not only used for physical hardware but also for theoretical models in computer science. When Boolean 
                    functions are used to construct a computational model rather than a physical device, we refer to them as <strong>Boolean circuits</strong>. 
                    These circuits serve as a fundamental concept in computational complexity theory, where they help analyze the efficiency and 
                    limitations of different computational processes. Here, we only introduce the definition of Boolean circuits. We will revisit this topic 
                    after learning complexity theory in the future.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Definition: Boolean Circuit</span>
                    <p>
                        A <strong>Boolean circuit</strong> is a <strong>directed acyclic graph (DAG)</strong> 
                        where nodes (often called gates) represent computational steps. The nodes are classified as:
                    </p>
                    <ul style="padding-left: 40px;">
                        <li><strong>Input nodes</strong> (sources): Represent Boolean variables.</li>
                        <li><strong>Gate nodes</strong> (internal): Each computes a Boolean function from a 
                            <strong>functionally complete set</strong> (e.g., \(\{\wedge, \vee, \neg\}\) or \(\{\uparrow\}\)) of its inputs.</li>
                        <li><strong>Output nodes</strong> (sinks): Produce the final result(s) of the circuit.</li>
                    </ul>
                    <p>
                        The <strong>size</strong> of a circuit is its total number of gates, and its 
                        <strong>depth</strong> is the length of the longest path from any input to an output.
                    </p>
                </div>   

                <div class="proof">
                    <span class="proof-title">Example: Circuit for XOR</span>
                    <p>
                        The expression \(P \oplus Q = (P \wedge \neg Q) \vee (\neg P \wedge Q)\) 
                        is realized by the following Boolean circuit using the standard gate set \(\{\neg, \wedge, \vee\}\):
                    </p>
                    <div style="text-align: center;">
                        <img src="Images/xor_circuit.png" alt="Boolean circuit computing XOR with NOT, AND, and OR gates" class="responsive-image">
                    </div>
                    <p>
                        This circuit consists of:
                    </p>
                    <ul style="padding-left: 40px;">
                        <li><strong>2 Input nodes:</strong> \(P\) and \(Q\).</li>
                        <li><strong>5 Gate nodes:</strong> 2 NOT gates, 2 AND gates, and 1 OR gate. Thus, the <strong>size</strong> is 5.</li>
                        <li><strong>1 Output node:</strong> Producing the final result of \(P \oplus Q\).</li>
                    </ul>
                    <p>
                        The <strong>depth</strong> of this circuit is 3. For instance, the path \(P \to \text{NOT} \to \text{AND} \to \text{OR}\) 
                        is one of the longest paths, passing through three consecutive gates.
                    </p>
                </div>

                <p>
                    The DAG structure ensures that computation proceeds in a well-defined order from inputs to output, 
                    with no feedback loops. The <strong>size</strong> of a circuit (number of gates) and its 
                    <strong>depth</strong> (length of the longest path from input to output) are key measures in 
                    <a href="time_complexity.html"><strong>complexity theory</strong></a>.
                </p>

                <p>
                    Boolean logic underlies virtually all of computer science - from the physical transistor level to 
                    the abstract models studied in complexity theory. The operations introduced here appear throughout 
                    the curriculum: XOR is fundamental to <strong>finite field arithmetic</strong> in abstract algebra, 
                    in cryptography, and Boolean circuits provide a computational model complementary to the 
                    <a href="turing_machine.html"><strong>Turing machine</strong></a>.
                </p>

            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>