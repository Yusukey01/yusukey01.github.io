---
layout: default
title: Neural Networks Basics
topic_id: ml-4
level: detail
uses_math: true
uses_python: false
---
<!DOCTYPE html>
<html>
    <body> 
        {% include learning_resource_schema.html topic_id=page.topic_id %}
        
        <div class="hero-section">
            <h1 class="webpage-name"> Neural Networks Basics</h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#MLP">Multilayer Perceptron (MLP)</a>
            <a href="#activation">Activation Functions</a>
            <a href="#learning">Learning in Neural Networks</a>
            <a href="#demo">Neural Networks Demo</a>
            <a href="#GPU">Development of Deep Learning</a>    
        </div> 

        <div class="container">  

            <section id="MLP" class="section-content">
                <h2>Multilayer Perceptron (MLP)</h2>

                <p>
                    In <a href="intro_classification.html"><strong>Part 3</strong></a>, we saw that logistic regression defines a <em>linear</em> decision boundary 
                    and that the kernel trick can extend this to nonlinear settings - but requires choosing a fixed feature map. Neural networks take a fundamentally 
                    different approach: they <em>learn</em> the feature representation jointly with the classifier by composing many simple, differentiable transformations. 
                    The resulting gradients are computed via the <a href="../Calculus/jacobian.html"><strong>Chain Rule</strong></a>, which we formalize in 
                    this page as the backpropagation algorithm.
                </p>

                <p> 
                    The key idea of <strong>deep neural networks (DNNs)</strong> is "composing" a vast number of simple functions to make a huge complex function.
                    We focus on a specific type of DNN known as the <strong>multilayer perceptron (MLP)</strong>, also referred to as a <strong>feedforward neural network (FFNN)</strong>.
                </p>

                <p>
                    An MLP defines a composite function of the form: 
                    \[
                    f(x ; \theta) = f_L (f_{L-1}(\cdots(f_1(x))\cdots))
                    \]
                
                    where each component function \( f_\ell(x) = f(x; \theta_\ell) \) represents the transformation at 
                    <strong>layer</strong> \( \ell \,\), \( x \in \mathbb{R}^D \) is an input vector with \( D \) features, and 
                    \(\theta\) is a collection of parameters (weights and biases):
                    \[
                    \theta = \{ \theta_\ell \}_{\ell=1}^L \text{ ,where } \theta_\ell = \{ W^{(\ell)}, b^{(\ell)} \}.
                    \]
                </p>

                <p>
                     Each layer is assumed to be <strong>differentiable</strong> and consists of two operations: an <strong>affine transformation</strong> followed 
                     by a <strong>non-linear differentiable activation function</strong> \( g_\ell : \mathbb{R} \to \mathbb{R}\). An MLP consists of an <strong>input layer</strong>, 
                     one or more <strong>hidden layers</strong>, and an <strong>output layer</strong>.
                </p>

                <p>
                    We define the hidden units \(z^{(\ell)}\) at each layer \(\ell\) passed  elementwise through the activation:
                    \[
                    z^{(\ell)} = g_{\ell}(b^{(\ell)} + W^{(\ell)}z^{(\ell -1)}) = g_{\ell}(a^{(\ell)})
                    \]
                    where \(a^{(\ell)}\) is called the <strong>pre-activations</strong>, and the output of the network is denoted by
                    \(\hat{y} = h_\theta(x) = g_L(a^{(L)})\).
                </p>

                 <p>
                    <strong>Note:</strong> Input data is typically stored as an \( N \times D \) <strong>design matrix</strong>, where each 
                    row corresponds to a data point and each column to a feature. This is referred to as <strong>structured data</strong> or 
                    <strong>tabular data</strong>. In contrast, for <strong>unstructured data</strong> such as images or text, different architectures 
                    are used:
                </p>

                <ul style="padding-left: 40px;">
                    <li><strong>Convolutional Neural Networks (CNNs)</strong> for images</li>
                    <li><strong>Recurrent Neural Networks (RNNs)</strong> and <strong>Transformers</strong> for sequential data (e.g. text)</li>
                </ul>

                <div class="theorem">
                    <span class="theorem-title">Definition: Multilayer Perceptron</span>
                    <p>
                        A <strong>multilayer perceptron (MLP)</strong> with \(L\) layers defines a parameterized function 
                        \[
                        f(x; \theta) = f_L \circ f_{L-1} \circ \cdots \circ f_1(x),
                        \] 
                        where each layer computes
                        \[
                        z^{(\ell)} = g_\ell\!\left(W^{(\ell)} z^{(\ell-1)} + b^{(\ell)}\right),
                        \]
                        with \(z^{(0)} = x\), weight matrices \(W^{(\ell)} \in \mathbb{R}^{d_\ell \times d_{\ell-1}}\), bias vectors 
                        \(b^{(\ell)} \in \mathbb{R}^{d_\ell}\), and nonlinear activation functions \(g_\ell\). The output layer 
                        uses an activation appropriate to the task (sigmoid for binary classification, softmax for multiclass, identity for regression).
                    </p>
                </div>

                <p>
                    In particular, modern <strong>Large Language Models (LLMs)</strong> are built upon the <a href="deep_nn.html#transformer"><strong>Transformer architecture</strong></a>. 
                    The Transformer's <strong>Self-Attention mechanism</strong> has largely replaced <strong>RNNs</strong> in natural language processing 
                    because it allows for global dependencies to be modeled in parallel, bypassing the sequential bottleneck and vanishing gradient issues 
                    inherent in recurrent designs.
                </p>

                <div class="insight-box">
                    <h3>Are RNNs Outdated?</h3>
                    <p>
                        Although Transformers dominate high-compute tasks, "Recurrent" logic remains essential. Modern <strong>State Space Models (SSMs)</strong>, 
                        such as <strong>Mamba</strong>, have revitalized this field by leveraging hardware-aware parallel algorithms for training while maintaining the 
                        efficient inference characteristic of RNNs.
                    </p>
                    <ul style="padding-left: 40px;">
                        <li>
                            <strong>Inference Efficiency:</strong><br>
                            Standard Transformers suffer from \(O(L^2)\) computational complexity. In contrast, SSMs maintain <strong>linear complexity</strong> 
                            \(O(L)\) and constant \(O(1)\) memory overhead per step during inference. This makes them ideal for <strong>embedded devices</strong> 
                            and <strong>real-time control systems</strong> where memory bandwidth is a bottleneck.
                        </li>
                        <li>
                            <strong>Infinite Horizons and State Compression:</strong><br>
                            By updating a fixed-size latent state, recurrent systems can theoretically process continuous data streams indefinitely 
                            without the quadratic memory growth. However, it is important to note that while the <strong>physical context window</strong> 
                            is effectively infinite, the <strong>information density</strong> is constrained by the fixed state size, meaning the model 
                            must selectively forget or compress older information as the sequence progresses.
                        </li>
                    </ul>

                    <p style="font-size: 0.9em;">
                        <strong>References:</strong><br>
                        [1] Gu, A., & Dao, T. (2023). <em>Mamba: Linear-Time Sequence Modeling with Selective State Spaces</em>. <a href="https://arxiv.org/abs/2312.00752" target="_blank">arXiv:2312.00752</a>.<br>
                        [2] Ravi, D., et al. (2021). <em>Recurrent Neural Network for Human Activity Recognition in Embedded Systems</em>. <a href="https://www.mdpi.com/2079-9292/10/12/1434" target="_blank">Electronics, 10(12), 1434</a>.
                    </p>
                </div>

            </section>

            <section id="activation" class="section-content">
                <h2>Activation Functions</h2>

                <p>
                    Without a <strong>non-linear</strong> activation function, a neural network composed of multiple layers would reduce to a 
                    single affine transformation. For example, a two-layer linear network computes:
                    \[
                    f(x ; \theta) = W^{(2)}(W^{(1)} x + b^{(1)}) + b^{(2)} = (W^{(2)}W^{(1)})x + (W^{(2)}b^{(1)} + b^{(2)}) = \tilde{W}x + \tilde{b}.
                    \]
                    This composition remains an <strong>affine</strong> transformation of \( x \), and therefore is incapable of representing non-linear decision boundaries. 
                    Non-linear activation functions are necessary to break this linearity.
                </p>

                <p>
                    Historically, a common choice was the <strong>sigmoid (logistic)</strong> activation function:
                    \[
                    \sigma(a) = \frac{1}{1+e^{-a}}.
                    \]
                    However, sigmoid functions saturate for large positive or negative inputs: \( \sigma(a) \to 1 \) as \( a \to +\infty \), and \( \sigma(a) \to 0 \) as \( a \to -\infty \). 
                    In these regions, the gradient \(\sigma'(a) = \sigma(a)(1-\sigma(a))\) becomes very small (approaching zero), leading to the <strong>vanishing gradient problem</strong>. 
                    During backpropagation, gradients are multiplied layer by layer, so very small gradients in deeper layers become exponentially smaller as they propagate backward, making 
                    learning slow or unstable in deep networks.

                </p>
                <p>
                    To address this, modern networks often use the <strong>Rectified Linear Unit (ReLU)</strong>:
                    \[
                    g(a) = \max(0, a) = a \mathbb{I}(a>0)
                    \]
                    ReLU's derivative is 1 for positive inputs and 0 for negative inputs, avoiding the exponential decay of gradients that occurs with sigmoid functions. 
                    ReLU introduces non-linearity while preserving gradient magnitude for positive inputs. It is computationally simple and helps maintain gradient flow 
                    during training, which is why it is now a standard choice in modern neural network architectures.
                </p>
                
                <p>
                    <strong>Note:</strong> Strictly speaking, the ReLU function is not differentiable at \( a = 0 \). In practice, optimization algorithms rely on the 
                    concept of <strong>subgradients</strong>, explicitly assigning a derivative of \( 0 \) (or sometimes \( 1 \)) at exactly \( a = 0 \).
                </p>

                <p>
                    <strong>Note:</strong> While ReLU solves the vanishing gradient problem, it can suffer from the "dying ReLU" problem where neurons become inactive 
                    (always output zero) and stop learning. This occurs when neurons consistently receive negative inputs, causing their gradients to be permanently zero.
                </p>
            </section>

            <section id="learning" class="section-content">
                <h2>Learning in Neural Networks</h2>

                <p> 
                    Training the network is finding parameters \( \theta = \{ \theta_\ell \}_{\ell=1}^L \), where 
                    \( \theta_\ell = \{ W^{(\ell)}, b^{(\ell)} \} \) that minimize the empirical risk (average loss over all training data):
                    \[
                    J(\theta) = \frac{1}{N} \sum_i \mathcal{L}(y_i, \hat{y_i})
                    \]
                    where \(\hat{y_i} = h_{\theta}(x_i)\) is the network's prediction.
                </p>
                <p>
                    For the binary classification, a common choice can be
                    <a href="../Probability/entropy.html"><strong>binary cross-entropy</strong></a>:
                    \[
                     \mathcal{L}(y, \hat{y}) = -y \log(\hat{y}) - (1-y) \log(1-\hat{y}) 
                    \]
                </p>
                <p>
                    The optimization is done by performing a <a href="../Calculus/gradient.html"><strong>gradient-based optimization method </strong></a> which 
                    iteratively updates parameters in the direction of negative gradient:
                    \[
                    \theta \leftarrow \theta - \alpha \nabla_{\theta} J(\theta)
                    \]
                    where \(\alpha\) is the learning rate. 
                </p>

                <p>
                    Our demo employs <strong>mini-batch gradient descent</strong>, which computes gradients on a small random subset of the data at 
                    each iteration. This provides a good balance between computational efficiency and gradient quality, often leading to faster convergence 
                    and better generalization compared to using the entire dataset at once.
                </p>

                <p>
                    The gradients are computed efficiently by the <a href="../Calculus/jacobian.html"><strong>backpropagation</strong></a> 
                    algorithm. Backprop is an efficient application of the chain rule starting from the gradient of the loss w.r.t the 
                    output and working backwards. The algorithm computes all gradients in just two passes through the network:
                </p>
                
                <div class="pseudocode">
                    <span class="pseudocode-title">Algorithm: BACKPROPAGATION</span>
                    <strong>Consider an MLP with L layers and a loss function \(\mathcal{L}\)</strong>
                    <strong>Input:</strong> Data point \((x, y)\)
                    <strong>// Forward Pass</strong>
                    &emsp;\(z^{(0)} = x\); 
                    &emsp;<strong>for \(\ell = 1 : L\) do</strong>
                    &emsp;&emsp;&emsp; \(a^{(\ell)} = W^{(\ell)} z^{(\ell-1)} + b^{(\ell)}\); 
                    &emsp;&emsp;&emsp; \(z^{(\ell)} = g_\ell(a^{(\ell)})\);
                    &emsp;\(\hat{y} = z^{(L)}\);
                    &emsp;Compute Loss \(\mathcal{L}(y, \hat{y})\);

                    <strong>// Backward Pass</strong>
                    &emsp;\(u^{(L)} = \nabla_{\hat{y}} \mathcal{L}\); // Gradient of the loss wrt the network output
                    &emsp;<strong>for \(\ell = L : 1\) do</strong>
                    &emsp;&emsp;&emsp; \(\delta^{(\ell)} = u^{(\ell)} \odot g_\ell'(a^{(\ell)})\); // Element-wise multiplication
                    &emsp;&emsp;&emsp; \(\nabla_{W^{(\ell)}} \mathcal{L} = \delta^{(\ell)} (z^{(\ell-1)})^\top\);
                    &emsp;&emsp;&emsp; \(\nabla_{b^{(\ell)}} \mathcal{L} = \delta^{(\ell)}\);
                    &emsp;&emsp;&emsp; \(u^{(\ell-1)} = (W^{(\ell)})^\top \delta^{(\ell)}\); // Gradient wrt the input of the current layer
                    <strong>Output:</strong> \(\{\nabla_{W^{(\ell)}} \mathcal{L},\; \nabla_{b^{(\ell)}} \mathcal{L}\}_{\ell=1}^L\)
                </div>
              
            </section>

            <section id="demo" class="section-content">
                <h2>Neural Networks Demo</h2>
                <div id="neural_network_visualizer"></div>
                <p>
                    This interactive demo showcases how a simple neural network can learn to classify non-linear patterns. 
                    You can generate datasets, tweak model parameters, and visualize the training process in real time.
                </p>

                <ul style="padding-left: 40px;">
                    <li><strong>Model Architecture:</strong>
                    <ul style="padding-left: 40px;">
                        <li>2 input features (\(x_1\) and \(x_2\))</li>
                        <li>1 hidden layer with ReLU activation (adjustable number of units)</li>
                        <li>1 output unit with sigmoid activation for binary classification</li>
                    </ul>
                    </li>
                    <li><strong>Forward Pass:</strong> 
                        The network computes predictions by applying matrix operations and non-linear activations. Selecting a 
                        demo point shows a step-by-step computation.
                    </li>
                    <li><strong>Training:</strong>
                        The network is trained using <strong>mini-batch gradient descent with backpropagation</strong> to minimize 
                        binary cross-entropy loss. Each iteration uses a small, randomly sampled subset of the training data to 
                        update weights.
                    <ul style="padding-left: 40px;">
                        <li>Faster and more stable than full-batch training</li>
                        <li>Helps escape flat regions and saddle points</li>
                        <li>More closely mirrors how real-world neural networks are trained</li>
                    </ul>
                    </li>
                    <li><strong>Training Optimizations:</strong>
                    <ul style="padding-left: 40px;">
                        <li>Dynamic learning rate adjustment</li>
                        <li><strong>Gradient clipping</strong>: Prevents instability due to the <strong>exploding gradients</strong> by scaling them when their norm exceeds a threshold.</li>
                        <li>Early stopping when performance stabilizes</li>
                        <li>\(\ell_2\) regularization (λ) to reduce overfitting</li>
                    </ul>
                    </li>
                    <li><strong>Visualizations:</strong>
                    <ul style="padding-left: 40px;">
                        <li>Color-coded data points for training and test sets</li>
                        <li>Decision boundary (green) shows where prediction = 0.5</li>
                        <li>Probability contours reveal model confidence</li>
                        <li>Dynamic network graph and forward pass breakdown</li>
                    </ul>
                    </li>
                </ul>
                
                <h3>Try Adjusting:</h3>
                <ul style="padding-left: 40px;">
                    <li><strong>Hidden Units:</strong> More neurons allow for more complex decision boundaries</li>
                    <li><strong>Regularization (λ):</strong> Helps prevent overfitting by discouraging large weights</li>
                    <li><strong>Learning Rate:</strong> Controls how quickly the model updates</li>
                    <li><strong>Max Iterations:</strong> Sets how long the training runs before stopping</li>
                </ul>
            </section>

            <section id="GPU" class="section-content">
                <h2>Development of Deep Learning</h2>

                <p>
                    The modern revolution in deep learning has been driven not only by algorithmic advances, but also by dramatic improvements in 
                    hardware—especially the rise of <strong>graphics processing units (GPUs)</strong>. Originally designed to accelerate 
                    <strong>matrix-vector computations</strong> for real-time rendering in video games, GPUs turned out to be ideally suited for 
                    the linear algebra operations at the heart of neural networks.
                </p>

                <p>
                    In the early 2010s, researchers discovered that GPUs could speed up deep learning training by orders of magnitude compared to 
                    traditional CPUs. This enabled the training of large neural networks on <strong>large labeled datasets</strong>, like ImageNet, 
                    which led to breakthroughs in computer vision, <strong>speech recognition</strong> (converting spoken language to text), and broader 
                    <strong>natural language processing (NLP)</strong> tasks such as translation, summarization, and question answering. Today, GPUs are 
                    a core component in AI research and development, alongside other fields such as scientific computing, complex simulations, and even 
                    cryptocurrency mining.
                </p>

                <p>
                    Zooming out further, GPUs themselves rely on foundational advances in <strong>semiconductor</strong> technology. Semiconductors are 
                    materials whose conductivity can be precisely controlled, making them the backbone of all modern electronics — from GPUs and CPUs to 
                    memory chips and mobile devices. By using advanced fabrication techniques and nanometer-scale engineering, manufacturers can pack 
                    billions of <strong>transistors</strong> onto a single chip. This density of computation enables the incredible power of today's 
                    hardware and fuels the era of <strong>foundation models</strong>, including <strong>large language models (LLMs)</strong>.
                </p>

                <p>
                    With the architecture and training procedure of neural networks established, a natural question arises: how exactly are the gradients 
                    \(\nabla_\theta J(\theta)\) computed for arbitrary computational graphs? In <a href="autodiff.html"><strong>Part 5: Automatic 
                    Differentiation</strong></a>, we generalize backpropagation beyond sequential layers to the full framework of reverse-mode automatic 
                    differentiation on directed acyclic graphs.
                </p>

            </section>

        </div>
        <script src="/js/main.js"></script> 
        <script src="/js/sec5_p4_intro_nn.js"></script>
    </body>
</html>