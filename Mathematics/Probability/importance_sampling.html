---
layout: default
title: Importance Sampling
level: detail
description: Introduction to importance sampling for efficient Monte Carlo estimation with applications to modern AI and machine learning.
uses_math: true
uses_python: false
---

<!DOCTYPE html>
<html>
    <body>
        <!-- Meta script for importance_sampling.html -->
        <script type="application/ld+json">
        {
        "@context": "https://schema.org",
        "@type": "LearningResource",
        "name": "{{ page.title }}",
        "description": "{{ page.description }}",
        "learningResourceType": "lesson",
        "educationalUse": "instruction",
        "educationalLevel": "university",
        "interactivityType": "{% if page.content contains 'Interactive Demo' or page.content contains 'demo' %}active{% else %}expositive{% endif %}",
        "author": {
            "@type": "Person",
            "name": "Yusuke Yokota",
            "jobTitle": "Mathematics & Computer Science Educator"
        },
        "publisher": {
            "@type": "Organization",
            "name": "MATH-CS COMPASS",
            "url": "https://yusukey01.github.io"
        },
        "about": [
            { "@type": "Thing", "name": "Importance Sampling" },
            { "@type": "Thing", "name": "Direct Importance Sampling" },
            { "@type": "Thing", "name": "Self-Normalized Importance Sampling" },
            { "@type": "Thing", "name": "Annealed Importance Sampling" },
            { "@type": "Thing", "name": "AIS" },
            { "@type": "Thing", "name": "Importance Weights" },
            { "@type": "Thing", "name": "Proposal Distribution" },
            { "@type": "Thing", "name": "Target Distribution" },
            { "@type": "Thing", "name": "Monte Carlo Methods" },
            { "@type": "Thing", "name": "Variance Reduction" },
            { "@type": "Thing", "name": "RLHF" },
            { "@type": "Thing", "name": "Off-Policy Learning" },
            { "@type": "Thing", "name": "Variational Inference" },
            { "@type": "Thing", "name": "Bayesian Inference" },
            { "@type": "Thing", "name": "Normalizing Constant" },
            { "@type": "Thing", "name": "Partition Function" }
        ],
        "teaches": [
            "Importance sampling fundamentals",
            "Direct and self-normalized importance sampling",
            "Annealed importance sampling",
            "Applications to modern AI"
        ],
        "isPartOf": {
            "@type": "Course",
            "name": "Probability & Statistics",
            "description": "Explore fundamental concepts of probability and statistics essential for machine learning",
            "provider": {
            "@type": "Organization",
            "name": "MATH-CS COMPASS",
            "url": "https://yusukey01.github.io"
            },
            "instructor": {
            "@type": "Person",
            "name": "Yusuke Yokota",
            "jobTitle": "Mathematics & Computer Science Educator"
            },
            "courseCode": "III",
            "hasCourseInstance": {
            "@type": "CourseInstance",
            "courseMode": "online",
            "courseWorkload": "PT2H30M",
            "instructor": {
                "@type": "Person",
                "name": "Yusuke Yokota"
            }
            },
            "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock",
            "category": "free"
            }
        }
        }
        </script>
        <!-- WebApplication Schema for Interactive Tools -->
        <script type="application/ld+json">
        {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "{{ page.title }} Interactive Tool",
        "description": "Interactive tool for exploring {{ page.title | downcase }} concepts with real-time visualizations and computational examples",
        "applicationCategory": "EducationalApplication",
        "operatingSystem": "Web Browser",
        "url": "https://yusukey01.github.io{{ page.url }}",
        "author": {
            "@type": "Person",
            "name": "Yusuke Yokota"
        },
        "applicationSubCategory": "Mathematical Computation Tool",
        "featureList": [
            "Interactive mathematical visualization",
            "Real-time parameter adjustment",
            "Educational demonstrations",
            "Statistical computation",
            "Importance sampling simulation",
            "Variance comparison",
            "AIS demonstration"
        ],
        "isAccessibleForFree": true,
        "educationalUse": "instruction",
        "educationalLevel": "university"
        }
        </script>
        <div class="hero-section">
            <h1 class="webpage-name">Importance Sampling
            </h1>
        </div>

        {% include section_navigation.html %}

        <div class="topic-nav">
            <a href="#intro">Introduction</a>
            <a href="#direct">Direct Importance Sampling</a>
            <a href="#selfnorm">Self-Normalized IS</a>
            <a href="#ais">Annealed Importance Sampling</a>
        </div> 

        <div class="container">  
            <section id="intro" class="section-content">
                <h2>Introduction</h2>
                
                <p>
                    <strong>Importance sampling</strong> is a fundamental Monte Carlo technique for estimating expectations under one probability 
                    distribution by sampling from a different, more convenient distribution. This approach addresses two critical challenges in 
                    computational statistics and machine learning when:
                    <ul style="padding-left: 40px;">
                        <li>direct sampling from the target distribution is difficult or impossible.</li>
                        <li>we want to focus computational resources on the most "important" regions of the distribution.</li>
                    </ul>
                </p>

                <p>
                    Suppose we want to compute the expectation of a <strong>target function</strong> \(\varphi(\mathbf{x})\) under a 
                    <strong>target distribution</strong> \(\pi(\mathbf{x})\):
                    \[
                    I = \mathbb{E}_{\pi}[\varphi(\mathbf{x})] = \int \varphi(\mathbf{x}) \pi(\mathbf{x}) \, d\mathbf{x}
                    \]
                </p>
                <p>
                    Standard <a href="monte_carlo.html"><strong>Monte Carlo estimation</strong></a> would draw independent samples 
                    \(\mathbf{x}_1, \ldots, \mathbf{x}_n \sim \pi(\mathbf{x})\) and approximate:
                    \[
                    I \approx \hat{I}_{\text{MC}} = \frac{1}{N_s} \sum_{n=1}^{N_s} \varphi(\mathbf{x}_n).
                    \]
                </p>
                <p>
                    However, this approach fails when:
                    <ul style="padding-left: 40px;">
                        <li>Sampling from \(\pi(\mathbf{x})\) is computationally expensive or infeasible</li>
                        <li>The normalizing constant of \(\pi(\mathbf{x})\) is unknown (common in Bayesian inference)</li>
                        <li>\(\varphi(\mathbf{x})\) has large values only in regions where \(\pi(\mathbf{x})\) has low probability (rare events)</li>
                    </ul>
                </p>

                <p>
                    <strong>Importance sampling</strong> solves these problems by introducing a <strong>proposal distribution</strong> 
                    (or <strong>importance distribution</strong>) \(q(\mathbf{x})\) from which we can easily sample, then reweighting samples 
                    to account for the distribution mismatch.
                </p>

                <p>
                    Importance sampling has become essential in modern AI, particularly in the following domains:
                </p>

                <h4><strong>1. Reinforcement Learning from Human Feedback (RLHF)</strong></h4>
                <p>
                    Modern large language models (LLMs) like ChatGPT, are fine-tuned using RLHF, which fundamentally relies on 
                    importance sampling. The <strong>Proximal Policy Optimization (PPO)</strong> algorithm uses importance sampling to learn 
                    from data collected under an old policy while optimizing a new policy:
                    \[
                    L(\theta) = \mathbb{E}_{(s,a) \sim \mu}\left[\frac{\pi_\theta(a|s)}{\mu(a|s)} A(s,a)\right]
                    \]
                    where \(\mu\) is the behavior policy (old data) and \(\pi_\theta\) is the target policy being optimized. 
                    In practice, PPO clips this ratio to prevent overly large policy updates. Without importance 
                    sampling, we would need to collect entirely new data after each policy update, making RLHF expensive.
                </p>

                <h4><strong>2. Off-Policy Reinforcement Learning</strong></h4>
                <p>
                    In robotics, autonomous systems, and game AI, collecting on-policy data can be dangerous or expensive. Importance sampling 
                    enables learning from historical data, human demonstrations, or safer exploration policies. This is crucial for algorithms 
                    like Soft Actor-Critic (SAC), Conservative Q-Learning (CQL), and offline RL methods.
                </p>

                <h4><strong>3. Variational Inference and Deep Generative Models</strong></h4>
                <p>
                    Importance-weighted autoencoders (IWAE) use importance sampling to obtain tighter bounds on the evidence lower bound (ELBO), 
                    leading to better generative models and more accurate uncertainty estimates in Bayesian deep learning.
                </p>

                <h4><strong>4. Imbalanced Data and Rare Events</strong></h4>
                <p>
                    In applications like fraud detection, medical diagnosis of rare diseases, and AI safety, the events we care most about 
                    are extremely rare. Importance sampling allows us to oversample these critical cases and reweight appropriately, ensuring 
                    models do not ignore rare but important scenarios.
                </p>

                <h4><strong>5. Computing Normalizing Constants</strong></h4>
                <p>
                    Many probabilistic models in AI (Boltzmann machines, energy-based models, certain Bayesian posteriors) have intractable 
                    normalizing constants. Importance sampling, particularly <strong>annealed importance sampling</strong>, provides practical methods to 
                    estimate these constants, which is essential for model comparison and learning.
                </p>

                <p>
                    The critical insight is that importance sampling enables <strong>sample efficiency</strong>: in an era where data collection 
                    and computation are expensive, the ability to reuse and reweight existing data rather than collecting new samples is invaluable. 
                    This makes importance sampling one of the foundational techniques enabling practical, scalable AI systems.
                </p>
            </section>

            <section id="direct" class="section-content">
                <h2>Direct Importance Sampling</h2>
                
                <p>
                    The key mathematical insight behind importance sampling is the change of measure. We can rewrite the expectation under 
                    the target distribution \(\pi(\mathbf{x})\) as an expectation under some proposal distribution \(q(\mathbf{x})\):
                    \[
                    \begin{align*}
                    I &= \int \varphi(\mathbf{x}) \pi(\mathbf{x}) \, d\mathbf{x} \\\\
                      &= \int \varphi(\mathbf{x}) \frac{\pi(\mathbf{x})}{q(\mathbf{x})} q(\mathbf{x}) \, d\mathbf{x} \\\\
                      &= \mathbb{E}_{q}\left[\varphi(\mathbf{x}) \frac{\pi(\mathbf{x})}{q(\mathbf{x})}\right]
                    \end{align*}
                    \]
                </p>
                <p>
                    This identity holds for any \(q(\mathbf{x})\) that satisfies the support condition: 
                    \(q(\mathbf{x}) > 0\) whenever \(\pi(\mathbf{x}) \neq 0\).
                </p>
                <p>
                    The ratio
                    \[
                    \tilde{w}_n = \frac{\pi(\mathbf{x})}{q(\mathbf{x})}
                    \]
                    is called the <strong>importance weights</strong>. It measures how much more (or less) likely \(\mathbf{x}\) is under the target 
                    distribution \(\pi\) compared to the proposal distribution \(q\). Note that while \(\pi\) and \(q\) are normalized 
                    distributions, the weights \(\tilde{w}_n\) do not sum to any particular value.
                </p>
                <p>
                    Assume that the normalized \(\pi (\mathbf{x})\) can be evaluated, but we are not able to sample from it. 
                    If we draw \(N_s\) samples, \(\mathbf{x}_n \sim q(\mathbf{x})\), the <strong>direct importance sampling estimator</strong> is:
                    \[
                    \mathbb{E}[\varphi(\mathbf{x})] \approx \hat{I}_{\text{IS}} = \frac{1}{N_s} \sum_{n=1}^{N_s} \tilde{w}_n \varphi(x_n).
                    \]
                </p>
                <p>
                    This estimator is <strong>unbiased</strong>:
                    \[
                    \begin{align*}
                    \mathbb{E}_q[\hat{I}_{\text{IS}}] &= \mathbb{E}_q\left[\frac{1}{N_s}\sum_{n=1}^{N_s} \tilde{w}_n(\mathbf{x}_n)\varphi(\mathbf{x}_n)\right] \\\\
                                                      &= \mathbb{E}_q[\tilde{w}_n(\mathbf{x})\varphi(\mathbf{x})] \\\\
                                                      &= I
                    \end{align*}
                    \]
                </p>

                <p>
                    While the estimator is unbiased, its variance depends critically on the choice of \(q\):
                    \[
                    \text{Var}[\hat{I}_{\text{IS}}] = \frac{1}{N_s}\left(\mathbb{E}_q[\tilde{w}_n^2(\mathbf{x})\varphi^2(\mathbf{x})] - I^2\right)
                    \]
                </p>
                <p>
                    If the importance weights vary dramatically, a few samples will dominate the estimate, leading to high variance. 
                    This is quantified by the <strong>effective sample size (ESS)</strong>, which measures the number of independent 
                    samples that would provide the same statistical efficiency as the current weighted sample. The ESS can be computed 
                    in two equivalent ways:
                </p>
                <p>
                    <strong>Using unnormalized weights \(\tilde{w}_n\):</strong>
                    \[
                    \text{ESS} = \frac{\left(\sum_{n=1}^{N_s} \tilde{w}_n\right)^2}{\sum_{n=1}^{N_s} \tilde{w}_n^2}
                    \]
                </p>
                <p>
                    <strong>Using normalized weights \(W_n = \tilde{w}_n / \sum_{n'=1}^{N_s} \tilde{w}_{n'}\):</strong>
                    \[
                    \text{ESS} = \frac{1}{\sum_{n=1}^{N_s} W_n^2}
                    \]
                </p>
                <p>
                    These formulas are mathematically equivalent. The ESS ranges from 1 (maximum degeneracy, where all weight 
                    concentrates on one sample) to \(N_s\) (no degeneracy, where all weights are equal). A good rule of thumb is 
                    that if \(\text{ESS} < N_s/2\), the proposal distribution \(q(\mathbf{x})\) should be reconsidered, as this 
                    indicates that many samples have negligible contribution to the estimate.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Requirements for Direct Importance Sampling</span>
                    For direct importance sampling to be valid and practical:
                     <ul>
                        <li><strong>Support condition</strong>: \(q(\mathbf{x}) > 0\) whenever \(\pi(\mathbf{x}) > 0\)</li>
                        <li><strong>Normalization</strong>: Both \(\pi(\mathbf{x})\) and \(q(\mathbf{x})\) must be properly normalized probability distributions</li>
                        <li><strong>Evaluability</strong>: We must be able to evaluate \(\pi(\mathbf{x})\) and \(q(\mathbf{x})\) for any \(\mathbf{x}\)</li>
                        <li><strong>Sampling</strong>: We must be able to draw samples from \(q(\mathbf{x})\) efficiently</li>
                    </ul>
                </div>

            </section>

            <section id="selfnorm" class="section-content">
                <h2>Self-Normalized Importance Sampling</h2>
                
                <p>
                    In many practical applications, we can only evaluate the <strong>unnormalized target distribution</strong>:
                    \[
                    \tilde{\gamma}(\mathbf{x}) = Z \pi(\mathbf{x})
                    \]
                    where the normalization constant
                    \[
                    Z = \int \tilde{\gamma}(\mathbf{x})d\mathbf{x}
                    \]
                    is unknown or intractable. This situation is ubiquitous in Bayesian inference (where \(Z\) is the marginal 
                    likelihood), energy-based models (where \(Z\) is the partition function), and many other machine learning applications.
                </p>

                <p>
                    <strong>Self-normalized importance sampling (SNIS)</strong> addresses this by working with unnormalized weights 
                    and normalizing them within the estimator itself. We can rewrite the expectation as a ratio of two integrals:
                    \[
                    \begin{align*}
                    \mathbb{E}[\varphi(\mathbf{x})] &= \int \varphi(\mathbf{x}) \pi(\mathbf{x})d\mathbf{x} \\\\
                                                    &= \frac{\int \varphi(\mathbf{x})\tilde{\gamma}(\mathbf{x})d\mathbf{x}}
                                                            {\int \tilde{\gamma}(\mathbf{x})d\mathbf{x}} \\\\
                                                    &= \frac{\int \varphi(\mathbf{x})\frac{\tilde{\gamma}(\mathbf{x})}{q(\mathbf{x})}q(\mathbf{x})d\mathbf{x}}
                                                            {\int \frac{\tilde{\gamma}(\mathbf{x})}{q(\mathbf{x})}q(\mathbf{x})d\mathbf{x}} \\\\
                                                    &= \frac{\mathbb{E}_{q}\left[\varphi(\mathbf{x}) \frac{\tilde{\gamma}(\mathbf{x})}{q(\mathbf{x})}\right]}
                                                            {\mathbb{E}_{q}\left[\frac{\tilde{\gamma}(\mathbf{x})}{q(\mathbf{x})}\right]}
                    \end{align*}
                    \]
                </p>

                <p>
                    Sampling \(\mathbf{x}_n \sim q(\mathbf{x})\) for \(n = 1, \ldots, N_s\), we define the <strong>unnormalized importance weights</strong>:
                    \[
                    \tilde{w}_n = \frac{\tilde{\gamma}(\mathbf{x}_n)}{q(\mathbf{x}_n)}
                    \]
                    The <strong>self-normalized importance sampling estimator</strong> approximates both the numerator and denominator:
                    \[
                    \mathbb{E}[\varphi(\mathbf{x})] \approx \hat{I}_{\text{SNIS}} = \frac{\sum_{n=1}^{N_s} \tilde{w}_n\varphi(\mathbf{x}_n)}
                                                                                        {\sum_{n=1}^{N_s}\tilde{w}_n}
                                                            = \sum_{n=1}^{N_s} W_n \varphi(\mathbf{x}_n)
                    \]
                    where \(W_n = \tilde{w}_n/\sum_{n'=1}^{N_s}\tilde{w}_{n'}\) are the normalized weights introduced in the previous section.
                </p>

                <p>
                    This estimator is <strong>biased</strong> for finite \(N_s\) because it involves a ratio of random variables, 
                    but it is <strong>consistent</strong>: as \(N_s \to \infty\), the bias vanishes and the estimator converges 
                    almost surely to the true expectation.
                </p>

                <p>
                    Despite the bias, SNIS is the standard approach in practice for several important reasons. 
                    Most importantly, it only requires evaluating unnormalized densities \(\tilde{\gamma}(\mathbf{x})\) 
                    and \(q(\mathbf{x})\), making it applicable when the normalization constant \(Z\) is intractable—a 
                    common situation in Bayesian inference, energy-based models, and many machine learning applications. 
                    While SNIS can have a positive effect on the dispersion (variance) of the estimator in certain cases, 
                    it does not universally reduce variance compared to direct importance sampling. The key advantage is 
                    practical: SNIS enables estimation when direct importance sampling is impossible due to unknown 
                    normalization constants.
                </p>

            </section>

            <section id="ais" class="section-content">
                <h2>Annealed Importance Sampling (AIS)</h2>

                <p>
                    When the target distribution \(\pi(\mathbf{x})\) and proposal distribution \(q(\mathbf{x})\) 
                    have substantial distributional mismatch, importance sampling often fails due to extremely high 
                    variance in the importance weights. Most samples from \(q\) will have near-zero weight under \(\pi\), 
                    while a few rare samples will have enormous weights—a phenomenon known as <strong>weight degeneracy</strong>. 
                    This leads to a low effective sample size, meaning that despite drawing many samples, 
                    few actually contribute meaningfully to the estimate, making the results unreliable. 
                    <strong>Annealed importance sampling (AIS)</strong> addresses this fundamental limitation by introducing a sequence 
                    of intermediate distributions that smoothly bridge the gap between \(q\) and \(\pi\), dramatically reducing 
                    variance while maintaining unbiasedness.
                </p>

                <p>
                    We define a sequence of \(K+1\) distributions \(\pi_0, \pi_1, \ldots, \pi_K\) using an <strong>annealing schedule</strong> 
                    with parameters \(0 = \beta_0 < \beta_1 < \cdots < \beta_K = 1\). The unnormalized densities are defined as:
                    \[
                    \tilde{\pi}_k(\mathbf{x}) = \tilde{q}(\mathbf{x})^{1-\beta_k} \tilde{\pi}(\mathbf{x})^{\beta_k}
                    \]
                    where \(\tilde{q}\) and \(\tilde{\pi}\) are unnormalized versions of \(q\) and \(\pi\).
                </p>
                <p>
                    Notice that:
                </p>
                <ul style="padding-left: 40px;">
                    <li>At \(k=0\): \(\pi_0(\mathbf{x}) = q(\mathbf{x})\) (the proposal distribution)</li>
                    <li>At \(k=K\): \(\pi_K(\mathbf{x}) = \pi(\mathbf{x})\) (the target distribution)</li>
                    <li>For intermediate \(k\): \(\pi_k(\mathbf{x})\) is a geometric interpolation between \(q\) and \(\pi\)</li>
                </ul>
                <p>
                    Common choices for the annealing schedule include:
                </p>
                <ul style="padding-left: 40px;">
                    <li><strong>Linear</strong>: \(\beta_k = \frac{k}{K}\)</li>
                    <li><strong>Geometric</strong>: \(\beta_k = \left(\frac{k}{K}\right)^\alpha\) for some \(\alpha > 0\)</li>
                    <li><strong>Adaptive</strong>: chosen to maintain roughly constant ESS between steps</li>
                </ul>

                <p>
                    AIS generates samples by running a sequence of Markov chain transitions, starting from 
                    the simple proposal distribution and ending at the target distribution. For each run:
                </p>
                <ol style="padding-left: 40px;">
                    <li>Sample \(\mathbf{x}_0 \sim q(\mathbf{x})\) from the proposal distribution</li>
                    <li>For \(k = 1, \ldots, K\):
                        <ul>
                            <li>Apply Markov transition \(T_k\) that leaves \(\pi_k\) invariant: \(\mathbf{x}_k \sim T_k(\cdot|\mathbf{x}_{k-1})\)</li>
                        </ul>
                    </li>
                    <li>The final sample \(\mathbf{x}_K\) is approximately from the target distribution \(\pi\)</li>
                </ol>

                <p>
                    Each AIS run produces a sample and an associated importance weight. The weight for a sequence 
                    \(\mathbf{x}_0, \mathbf{x}_1, \ldots, \mathbf{x}_K\) is:
                    \[
                    w = \frac{\tilde{\pi}_1(\mathbf{x}_1)}{\tilde{\pi}_0(\mathbf{x}_1)} \cdot 
                        \frac{\tilde{\pi}_2(\mathbf{x}_2)}{\tilde{\pi}_1(\mathbf{x}_2)} \cdot 
                        \frac{\tilde{\pi}_3(\mathbf{x}_3)}{\tilde{\pi}_2(\mathbf{x}_3)} \cdots 
                        \frac{\tilde{\pi}_K(\mathbf{x}_K)}{\tilde{\pi}_{K-1}(\mathbf{x}_K)}
                    \]
                    which can be written more compactly as:
                    \[
                    w = \prod_{k=1}^{K} \frac{\tilde{\pi}_k(\mathbf{x}_k)}{\tilde{\pi}_{k-1}(\mathbf{x}_k)}
                    \]
                </p>

                <p>
                    Each ratio \(\frac{\tilde{\pi}_k(\mathbf{x}_k)}{\tilde{\pi}_{k-1}(\mathbf{x}_k)}\) is typically close to 1 
                    (unlike the direct ratio \(\frac{\tilde{\pi}(\mathbf{x})}{\tilde{q}(\mathbf{x})}\)), which keeps the weights 
                    stable and reduces variance. The key insight is that we evaluate both densities at the **same** point \(\mathbf{x}_k\).
                </p>

                <p>
                    AIS is particularly powerful for estimating ratios of normalizing constants. After running \(N_s\) independent 
                    AIS chains, each producing a weight \(w^{(s)}\), the average weight estimates the ratio of partition functions:
                    \[
                    \frac{Z_\pi}{Z_q} \approx \frac{1}{N_s} \sum_{s=1}^{N_s} w^{(s)}
                    \]
                </p>
                
                <p>
                    If \(Z_q\) is known (e.g., \(q\) is a Gaussian), we can estimate \(Z_\pi\). This is crucial for:
                </p>
                <ul style="padding-left: 40px;">
                    <li>Model comparison in Bayesian inference (estimating marginal likelihoods)</li>
                    <li>Training energy-based models and restricted Boltzmann machines</li>
                    <li>Computing partition functions in statistical physics</li>
                    <li>Evaluating evidence lower bounds in variational inference</li>
                </ul>

                <p>
                    The key insight is that by breaking the difficult transition from \(q\) to \(\pi\) into many small steps:
                </p>
                <ul style="padding-left: 40px;">
                    <li>Each individual importance weight ratio is close to 1, avoiding extreme weights</li>
                    <li>The product of many near-1 ratios has much lower variance than a single large ratio</li>
                    <li>The Markov transitions allow samples to adapt to each intermediate distribution</li>
                    <li>The method remains unbiased: estimates converge to correct values as the number of runs increases</li>
                </ul>
                <p>
                    The variance of AIS can be reduced by increasing the number of intermediate distributions \(K\). In practice, 
                    \(K = 100\) to \(K = 10000\) is common, depending on how different \(q\) and \(\pi\) are. The optimal choice 
                    balances computational cost (proportional to \(K\)) against the reduction in variance.
                </p>

                <div class="theorem">
                    <span class="theorem-title">Applications of AIS</span>
                    Annealed importance sampling is used in:
                    <ul>
                        <li><strong>Deep learning</strong>: Estimating partition functions of restricted Boltzmann machines (RBMs) 
                        and deep belief networks</li>
                        <li><strong>Bayesian inference</strong>: Computing marginal likelihoods for model selection and comparison</li>
                        <li><strong>Statistical physics</strong>: Estimating free energies in molecular simulations</li>
                        <li><strong>Variational inference</strong>: Obtaining tighter bounds and comparing variational approximations</li>
                        <li><strong>Rare event simulation</strong>: Handling multimodal distributions with isolated modes</li>
                    </ul>
                </div>
            </section>

             <section id="ais" class="section-content">
                <h2>Annealed Importance Sampling (AIS)</h2>
                <p>
                    Assume that we want to sample from some target distribution:
                    \[
                    p_0(\mathbf{x}) \propto f_0(\mathbf{x}),
                    \]
                    but it's difficult if \(p_0\) is complicated (e.g., high dimensional, and multi-modal). <strong>annealed importance sampling</strong> handles 
                    this issue. 
                </p>
                <p>
                    Suppose that we have a prior distribution: 
                    \[
                    p_n(\mathbf{x}) \propto f_n(\mathbf{x}).
                    \]
                    We construct a sequence of intermediate distributions from \(p_n\) to \(p_0\):
                    \[
                    f_j (\mathbf{x}) = f_0(\mathbf{x})^{\beta_j}f_n(\mathbf{x})^{1 - \beta_j}
                    \]
                    where \(1 = \beta_0 > \beta_1 > \cdots > \beta_n = 0\) and \(\beta_j\) is an inverse temperature. 
                </p>
                <p>
                    We sample a set of points from \(f_n, f_{n-1}, \cdots, f_0\). To sample from each \(f_j\), Given
                    a <strong>Markov chain</strong>:
                    \[
                    T_j(\mathbf{x}, \mathbf{x}') = p_j(\mathbf{x}' \mid \mathbf{x})
                    \]
                    which leaves \(p_0\) invariant.
                </p>

                <p>
                    Here, we can sample \(\mathbf{x}\) from \(p_0\) as follows:
                    Sample 
                    \[\mathbf{v}_n \sim p_n, \mathbf{v}_{n-1} \sim T_{n-1}(\mathbf{v}_n, \cdot), \cdots, \mathbf{v}_0 \sim T_0(\mathbf{v}_1, \cdot)
                    \]
                    Then we set \(\mathbf{x} = \mathbf{x}_0\) and give it weight: 
                    \[
                    w = \frac{f_{n-1}(\mathbf{v}_{n-1})}{f_n(\mathbf{v}_{n-1})}\frac{f_{n-2}(\mathbf{v}_{n-2})}{f_{n-1}(\mathbf{v}_{n-2})}\cdots\frac{f_1(v_1)}{f_2(\mathbf{v}_1)}\frac{f_0(v_0)}{f_1(\mathbf{v}_0)}. \tag{1}
                    \]
                </p>

                 <div class="proof">
                    <span class="proof-title">Proof:</span>
                    Consider the distribution on an extended state space \(\mathbf{v} = (\mathbf{v}_0, \cdots, \mathbf{v}_n)\):
                    \[
                    \begin{align*}
                    p(\mathbf{v}) &\propto \varphi(\mathbf{v}) = f_0(\mathbf{v})\tilde{T}_0 (\mathbf{v}_0, \mathbf{v}_1) \\\\
                                  &\propto p(\mathbf{v}_0)p(\mathbf{v}_1 \mid \mathbf{v}_0) \cdots p(\mathbf{v}_n \mid \mathbf{v}_{n-1}) 
                    \end{align*}
                    \]
                    where \tilde{T}_j is the reversal of \(T_j\):
                    \[
                    \begin{align*}
                    \tilde{T}_j(\mathbf{v}, \mathbf{v}') &= T_j(\mathbf{v}', \mathbf{v})p_j(\mathbf{v}') / p_j(\mathbf{v}) \\\\
                                                         &=  T_j(\mathbf{v}', \mathbf{v})f_j(\mathbf{v}') / f_j(\mathbf{v})
                    \end{align*}
                    \]
                    It is clear that
                    \[
                    \sum_{\mathbf{v}_1, \cdots, \mathbf{v}_n} \varphi(\mathbf{v}) = f_0(\mathbf{v}_0),
                    \]
                    and thus by sampling from \(p(\mathbf{v})\), we can effectively sample from \(p_0(\mathbf{x})\).  Moreover, we can sample 
                    on this extended sate space using this method, which corresponds to the following proposal:
                    \[
                    \begin{align*}
                    q(\mathbf{v}) &\propto g(\mathbf{v}) = f_n(\mathbf{v}_n)T_{n-1}(\mathbf{v_n}, \mathbf{v}_{n-1})\cdots T_2(\mathbf{v}_2, \mathbf{v}_1)T_0(\mathbf{v}_1, \mathbf{v}_0) \\\\
                                  &\propto p(\mathbf{v}_n)p(\mathbf{v}_{n-1} \mid \mathbf{v}_n)\cdots p(\mathbf{v}_1 \mid \mathbf{v}_0).
                    \end{align*}
                    \]
                    One can show that importance weights:
                    \[
                    w = \frac{\varphi(\mathbf{v}_0, \cdots, \mathbf{v}_n)}{g(\mathbf{v}_0, \cdots, \mathbf{v}_n)} 
                    \]
                    are given by Equation \(\tag{1}\). Since marginals of the sampled sequences from this extended model are equivalent to 
                    samples from \(p_0(\mathbf{x})\), we see that we are using the correct weights. 
                 </div>
                 <p>
                    Application is to evaluate a ratio of partition functions. 
                    \[
                    \begin{align*}
                    \frac{Z_0}{Z_n} &= \frac{\int \varphi(\mathbf{v})d\mathbf{v}}{\int g(\mathbf{v})d\mathbf{v}} \\\\
                                    &= \frac{\int \frac{\varphi(\mathbf{v})}{g(\mathbf{v})g(\mathbf{v})d\mathbf{v}}} {\int g(\mathbf{v})d\mathbf{v}} \\\\
                                    &= \mathbb{E}_g \left[ \frac{\varphi(\mathbf{v})}{g(\mathbf{v})}\right] \\\\
                                    &\approx \frac{1}{S}\sum_{s=1}^S W_s.
                    \end{align*}
                    \]
                    where \(W_s = \varphi(\mathbf{v}_s) / g(\mathbf{v}_S)\).
                 </p>
                 <p>
                    If \(f_0\) is a prior and \(f_n\) is the posterior, we can setimate \(Z_n = p(\mathcal{D})\) using the above equation, 
                    provided the prior has a known normalization constant \(Z_0\).
                 </p>
                    
             </section>
            
        </div>

        <script src="/js/main.js"></script>

    </body>
</html>