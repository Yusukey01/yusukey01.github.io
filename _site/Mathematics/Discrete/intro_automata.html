<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <title>Intro to Theory of Computation - MATH-CS COMPASS</title>
    
    
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
    </script>
    <script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff" as="font" type="font/woff2" crossorigin>
    
    
    

    <link rel="stylesheet" href="../../../css/styles.css?v=1.0.2">
  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Learn about basic automata theory and regular expressions.">
    <meta name="google-site-verification" content="IieEujypYW38caEVe8ymjczouNl56yxAy27iPztcfRA" />
    

    <link rel="manifest" href="/manifest.json">

    <!-- Theme color for Chrome, Android, and other browsers -->
    <meta name="theme-color" content="#007bff">
  
    <!-- iOS specific tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="MATH-CS COMPASS">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Icon references -->
    <link rel="icon" type="image/png" sizes="1280x1280" href="/images/maskable_icon_x1280.png?v=1.0.2">
    <link rel="icon" type="image/png" sizes="512x512" href="/images//maskable_icon_x512.png?v=1.0.2">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="/images/maskable_icon_x1280.png?v=1.0.2">
    <link rel="apple-touch-icon" href="/images/maskable_icon_x512.png?v=1.0.2">

    <!-- For Windows -->
    <meta name="msapplication-TileImage" content="/images/test1.png?v=1.0.2">
    <meta name="msapplication-TileColor" content="#007bff">

    <!-- Schema.org Structured Data for AI Optimization -->
    

    <!-- Article Schema for content pages -->
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Intro to Theory of Computation",
      "description": "Learn about basic automata theory and regular expressions.",
      "datePublished": "2024-01-01",
      "dateModified": "2025-01-01",
      "author": {
        "@type": "Person",
        "name": "Yusuke Yokota",
        "jobTitle": "Mathematics & Computer Science Educator",
        "knowsAbout": [
          "Linear Algebra",
          "Machine Learning",
          "Computer Science",
          "Mathematics"
        ]
      },
      "publisher": {
        "@type": "Organization",
        "name": "MATH-CS COMPASS",
        "url": "https://math-cs-compass.com",
        "logo": {
          "@type": "ImageObject",
          "url": "https://math-cs-compass.com/images/maskable_icon_x512.png"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://math-cs-compass.com/Mathematics/Discrete/intro_automata.html"
      },
      "about": [
        
        { "@type": "Thing", "name": "Discrete Mathematics" },
        { "@type": "Thing", "name": "Algorithms" }
        
      ],
      "educationalLevel": "university",
      "learningResourceType": "tutorial",
      "educationalUse": "instruction"
    }
    </script>
    
</head>

<body>
    <header>
    <nav class="navbar">
        <!-- Logo as Home Button -->
        <div class="logo-home">
            <a href="../../../index.html" 
               class="logo-link " 
               title="Home - Math-CS Compass">
                <img src="../../images/icon_x512.png" 
                     alt="Math-CS Compass Logo" 
                     class="nav-logo">
            </a>
        </div>

        <div class="search-container">
            <input type="text" id="search-input" placeholder="Search keywords...">
            <button id="search-button" aria-label="Search" title="Search website"><i class="fas fa-search"></i></button>
        </div>
        
        <div class="menu-toggle">
            <i class="fas fa-bars"></i>
        </div>
        
        <ul class="nav-links">
            <li><a href="../Linear_algebra/linear_algebra.html" >I - Linear Algebra to Algebraic Foundations</a></li>
            
            <li><a href="../Calculus/calculus.html" >II - Calculus to Optimization & Analysis</a></li>
            
            <li><a href="../Probability/probability.html" >III - Probability & Statistics</a></li>
            
            <li><a href="../Discrete/discrete_math.html" class="active">IV - Discrete Mathematics & Algorithms</a></li>
            
            <li><a href="../Machine_learning/ml.html" >V - Machine Learning</a></li>
        </ul>
    </nav>
</header>
    
    <!DOCTYPE html>
<html>
    <body>
        <!-- Meta script for intro_automata.html -->
        <script type="application/ld+json">
        {
        "@context": "https://schema.org",
        "@type": "LearningResource",
        "name": "Intro to Theory of Computation",
        "description": "Learn about basic automata theory and regular expressions.",
        "learningResourceType": "lesson",
        "educationalUse": "instruction",
        "educationalLevel": "university",
        "interactivityType": "active",
        "author": {
            "@type": "Person",
            "name": "Yusuke Yokota",
            "jobTitle": "Mathematics & Computer Science Educator"
        },
        "publisher": {
            "@type": "Organization",
            "name": "MATH-CS COMPASS",
            "url": "https://math-cs-compass.com"
        },
        "about": [
            { "@type": "Thing", "name": "Theory of Computation" },
            { "@type": "Thing", "name": "Automata Theory" },
            { "@type": "Thing", "name": "Finite Automata" },
            { "@type": "Thing", "name": "Finite State Machine" },
            { "@type": "Thing", "name": "Regular Languages" },
            { "@type": "Thing", "name": "Regular Expressions" },
            { "@type": "Thing", "name": "Formal Languages" },
            { "@type": "Thing", "name": "State Diagram" },
            { "@type": "Thing", "name": "Transition Function" },
            { "@type": "Thing", "name": "Accept States" },
            { "@type": "Thing", "name": "Start State" },
            { "@type": "Thing", "name": "Alphabet" },
            { "@type": "Thing", "name": "Regular Operations" },
            { "@type": "Thing", "name": "Union" },
            { "@type": "Thing", "name": "Concatenation" },
            { "@type": "Thing", "name": "Star Operation" },
            { "@type": "Thing", "name": "Kleene Star" },
            { "@type": "Thing", "name": "Deterministic Finite Automata" },
            { "@type": "Thing", "name": "DFA" },
            { "@type": "Thing", "name": "Nondeterministic Finite Automata" },
            { "@type": "Thing", "name": "NFA" },
            { "@type": "Thing", "name": "Power Set" },
            { "@type": "Thing", "name": "Epsilon Transitions" },
            { "@type": "Thing", "name": "Computational Models" },
            { "@type": "Thing", "name": "Compiler Design" },
            { "@type": "Thing", "name": "Natural Language Processing" }
        ],
        "teaches": [
            "Automata theory fundamentals",
            "Regular language construction",
            "Finite state machine design",
            "Regular expression applications"
        ],
        "isPartOf": {
            "@type": "Course",
            "name": "Discrete Mathematics & Algorithms",
            "description": "Explore the foundations of discrete mathematics and algorithms, covering graph theory, combinatorics, and the theory of computation",
            "provider": {
            "@type": "Organization",
            "name": "MATH-CS COMPASS",
            "url": "https://math-cs-compass.com"
            },
            "instructor": {
            "@type": "Person",
            "name": "Yusuke Yokota",
            "jobTitle": "Mathematics & Computer Science Educator"
            },
            "courseCode": "IV",
            "hasCourseInstance": {
            "@type": "CourseInstance",
            "courseMode": "online",
            "courseWorkload": "PT4H",
            "instructor": {
                "@type": "Person",
                "name": "Yusuke Yokota"
            }
            },
            "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock",
            "category": "free"
            }
        }
        }
        </script>

        <div class="hero-section">
            <h1 class="webpage-name">Intro to Theory of Computation
            </h1>
        </div>

        
  <div class="quick-jump-container">
    <button type="button" id="quick-jump-toggle" class="quick-jump-toggle">
      <i class="fas fa-list"></i> <strong>Section IV Navigation</strong>
    </button>
    <div id="quick-jump-menu" class="quick-jump-menu">
      <h3>Discrete Mathematics & Algorithms</h3>
      <div class="quick-jump-links">

        
        <a href="discrete_math.html">‚Üê Back to Section IV Overview</a>
        <hr style="margin: 8px 0; border: 1px solid #ddd;">
        
        
        <a href="intro_graph.html" >Part 1: Intro to Graph Theory</a>
        <a href="intro_combinatorics.html" >Part 2: Intro to Combinatorics</a>
        <a href="intro_automata.html" class="current-page">Part 3: Intro to Theory of Computation</a>
        <a href="boolean.html" >Part 4: Boolean Logic</a>
        <a href="context_free.html" >Part 5: Context-Free Languages</a>
        <a href="turing_machine.html" >Part 6: Turing Machines</a>
        <a href="time_complexity.html" >Part 7: Time Complexity</a>
        <a href="Eulerian.html" >Part 8: Eulerian & Hamiltonian</a>
        <a href="p_vs_np.html" >Part 9: Class NP</a>
      </div>
    </div>
</div>


        <div class="topic-nav">
            <a href="#intro">Introduction</a>
            <a href="#fa_rl">Finite automata & Regular Langualges</a>
            <a href="#regular_op">Regular Operations</a>
            <a href="#dfa">Deterministic & Nondeterministic Machine</a>
            <a href="#r_exp">Regular Expressions</a>
        </div> 

        <div class="container">  
           
            <section id="intro" class="section-content">
            <h2>Introduction</h2>
            <p>
            <strong>Automata theory</strong> is a foundational area of theoretical computer science and discrete mathematics that studies abstract 
            machines and computational problems. It provides a rigorous framework for understanding <strong>formal languages</strong>, state-based 
            computation, and algorithmic processes. For instance, automata theory is essential in compiler design, natural language processing, 
            software verification, and the study of complexity classes in the <strong>theory of computation</strong>. By exploring automata theory, we 
            will develop a deeper understanding of computation, logic, and the mathematical principles governing algorithmic processes.
            </p>
            </section>

            <section id="fa_rl" class="section-content">
            <h2>Finite automata & Regular Langualges</h2>
            <p>
            Since real computers are too complicated, depending on the features we want to focus on, we introduce different <strong>computational models</strong>. 
            The simplest computational model can be the <strong>finite automaton (finite state machine)</strong>.
            <br><br>
            A <strong>finite automaton</strong> is a 5-tuple \((Q, \Sigma, \delta, q_0, F)\) where
            <ul style="padding-left: 40px;">
                <li>\(Q\) is a finite set called the <strong>states</strong></li>
                <li>\(\Sigma\) is a finite set called the <strong>alphabet</strong></li>
                <li>\(\delta: Q \times \Sigma \to Q\) is the <strong>transition function</strong></li>
                <li>\(q_0 \in Q\) is the <strong>start state</strong></li>
                <li>\(F \subseteq Q\) is the set of <strong>accept states</strong></li>
            </ul>
            <br>
            Let \(A\) be the set of all strings that machine \(M\) accepts. We say that \(A\) is the <strong>language</strong> of 
            machine \(M\) and write:
            \[
            L(M) = A 
            \]
            We also say that \(M\) <strong>recognizes</strong> \(A\). Moreover, a language is called a <strong>regular language</strong> if 
            some finite automaton recognizes it.
            <br><br>
            Consider the following finite automaton. 
            <div style="text-align: center;">
                <img src="Images/DFA_example1.jpg" alt="Finite automata"  class="responsive-image">
            </div> 
            First, this directed multigraph is called the <strong>state diagram</strong> of the finite automaton.
            It has three states, \(Q = \{q_0, q_1, q_2\}\), where \(q_0\) is the start state, and \(F = \{q_1\}\) is the 
            accept state which is denoted by a double circle. The arrows are transitions \(\delta\) from one state to another state.
            This automaton processes some string(in this case, \(\Sigma =\{0, 1\}\)) as an input and returns either accept or reject 
            as an output. 
            <br><br>
            For example, if input string is \(1101101\), this automaton processes the string as follows: 
            <br><br>
            <div style="padding-left: 40px;">
            &emsp;&emsp;&emsp;Start reading
            <br>
            &emsp;&emsp;&emsp;Read 1, move from \(q_0\) to \(q_1\)
            <br>
            &emsp;&emsp;&emsp;Read 1, stay in \(q_1\)
            <br>
            &emsp;&emsp;&emsp;Read 0, move to \(q_2\)
            <br>
            &emsp;&emsp;&emsp;Read 1, move to \(q_1\)
            <br>
            &emsp;&emsp;&emsp;Read 1, stay in \(q_1\)
            <br>
            &emsp;&emsp;&emsp;Read 0, move to \(q_2\)
            <br>
            &emsp;&emsp;&emsp;Read 1, move to \(q_1\)
            <br>
            &emsp;&emsp;&emsp;End reading 
            <br>
            &emsp;&emsp;&emsp;Return "accept." 
            </div>
            <br><br>
            This automaton recognizes strings that end 1 with an even number of 0s. For example, "10100" is recognized because 
            it ends 1 with two 0s, but "1011000" is not because it ends three 0s. Also, a string ends 1 means it ends 1 with zero 0s, 
            and it is recognized since zero is an even number.
            </p>
            </section>

            <section id="regular_op" class="section-content">
            <h2>Regular Operations</h2>
            <p>
            Let \(A\) and \(B\) be languages. The regular operations are defined as follows:
            <ul style="padding-left: 40px;">
                <li><strong>Union</strong>:</li>
                \(A \cup B = \{x \, | \,x \in A \text{ or } x \in B\}\)
                <li><strong>Concatenation</strong>:</li>
                \(A \circ B = \{xy \, |\, x \in A \text{ and } y \in B\}\)
                <br>
                Note: \(\emptyset \circ A = \emptyset\), and \(\{\epsilon\} \circ A = A\).
                <br>
                Note: \(A \circ A = A^2\), and we define \(A^0 = \{\epsilon\}\).
                <li><strong>Star</strong>:</li>
                \(A^* = \{x_1x_2 \cdots x_k \, | \, k \geq 0 \text{ and each } x_i \in A\}\)
                <br>
                In other words, 
                <br>
                \(A^* = A^0 \cup A^1 \cup A^2 \cup \cdots\).
                <br>
                Note: The <strong>empty string</strong> \(\epsilon\) is always an element of \(A^*\) because 
                it includes the case where \(k=0\).
                <br>
                Note:\(\emptyset^* = \{\epsilon\}\) since \(\emptyset^* = \emptyset^0 \cup \emptyset^1 \cup \emptyset^2 \cup \cdots\).
            </ul>
            <br><br>
            For example, Let \(\Sigma = \{a, \, b, \, c, \, \cdots, \, x, \, y, \, z\}\). 
            If \(A = \{black, \, white\}\) and \(B = \{dog,  \, cat\}\), then 
            \[
            \begin{align*}
            &A \cup B = \{black, \, white, \, dog,  \, cat \} \\\\
            &A \circ B  = \{blackdog, \, blackcat, \, whitedog, \, whitecat\} \\\\
            &A^* = \{\epsilon, \, black, \, white, \, balckblack, \, blackwhite, \, whiteblack, \, whitewhite, \, blackblackblack, \, blackblackwhite, \,
            \   \cdots\}
            \end{align*}
            \]
            <div class="theorem">
                <span class="theorem-title">Theorem 1: </span>
                The class of regular languages is closed under regular operations. 
                <br>
                In other words, if languages \(A\) and \(B\) are regular, then \(A \cup B\), \(A \circ B\), 
                \(A^*\), and \(B^*\) are also regular languages.
            </div>  
            <div class="proof">
                <span class="proof-title">Proof: Closure under union</span> 
                Suppose we have two finite automata
                \[
                M_1 = (Q_1, \Sigma, \delta_1, q_{0_1}, F_1)
                \]
                and
                \[
                M_2 = (Q_2, \Sigma, \delta_2, q_{0_2}, F_2).
                \]
                These can recognize regular languages \(A_1\) and \(A_2\) respectively. 
                <br>
                Here, we can <strong>construct</strong> \(M_3\) to recognize \(A_1 \cup A_2\) as follows:
                \[
                M_3 = (Q_3, \Sigma, \delta_3, q_{0_3}, F_3)
                \]
                where 
                \[
                Q_3 = Q_1 \times Q_2 = \{(q_1, q_2)\, | \, q_1 \in Q_1 \text{ and } q_2 \in Q_2\}
                \]
                <br>
                \[
                \delta_3((q_1, q_2), a) = (\delta_1(q_1, a), \delta_2(q_2, a)) \quad \forall a \in  \Sigma
                \]
                <br>
                \[
                q_{0_3} = (q_{0_1}, q_{0_2})
                \]
                <br>
                \[
                F_3 = \{(q_1, q_2) \,| \, q_1 \in F_1 \text{ or } q_2 \in F_2 \}
                \] 
                which is the same as \((F_1 \times Q_2) \cup (Q_1 \times F_2)\).
                <br>
            </div>
             Note: If we say \(F_3 = F_1 \times F_2\), the resulting language is the <strong>intersection</strong>. Actually, the class of 
            regular languages is closed under intersection too. 
            </p>
            </section>

            <section id="dfa" class="section-content">
            <h2>Deterministic & Nondeterministic Machine</h2>
            <p>
            So far, we consider <strong>deterministic</strong> computations because we always know what the next state will be 
            based on the next input symbol. however, it is natural that a computation have multiple choices for the next state? 
            Such a computation is said to be <strong>nondeterministic</strong>. Technically, every deterministic finite automaton 
            (<strong>DFA</strong>) is a nondeterministic finite automaton (<strong>NFA</strong>) because determinism is just a 
            special case of nondeterminism.
            <br><br>
            A <strong>nondeterministic finite automaton</strong> is a 5-tuple \((Q, \Sigma, \delta, q_0, F)\) where 
            <ul style="padding-left: 40px;">
                <li>\(Q\) is a finite set of states</li>
                <li>\(\Sigma\) is a finite alphabet</li>
                <li>\(\delta: Q \times \Sigma_{\epsilon} \to \mathcal{P}(Q)\) is the transition function</li>
                <li>\(q_0 \in Q\) is the start state</li>
                <li>\(F \subseteq Q\) is the set of accept states</li>
            </ul>
            where \(\Sigma_{\epsilon} = \Sigma \cup \{\epsilon\}\) and \(\mathcal{P}(Q)\) is the <strong>power set</strong> of \(Q\).
            <br><br>
            Note: The power set of a set is the set of all possible subsets of that set, including the empty set and the set itself. For example, 
            if \(Q = \{a, b, c\}\), then \(\mathcal{P}(Q) = \{\emptyset, \{a\}, \{b\}, \{c\}, \{a, b\}, \{a, c\}, \{b, c\}, \{a, b, c\}\} \). So, if 
            a set has \(n\) elements, its power set has \(2^n\) elements. 
            <br><br>
            At each state, the NFA can split itself into multiple branches and keeps following all the possible branches in parallel. 
            In other words, the NFA can have multiple active states at once, while the DFA always has a single active state. If at least one 
            of branches accepts, then whole computation accepts. 
            <br>
            Note: The NFA sounds like parallel computation, but in "actual" parallel computation, multiple processors or threads execute 
            tasks concurrently, often with considerations for synchronization, communication, and resource sharing. NFAs don't model 
            these practical concerns. 
            <br><br>
            <div class="theorem">
                <span class="theorem-title">Theorem 2: </span>
               Every NFA  has an <strong>equivalent</strong> DFA. 
               <br>
               In other words, every NFA can be converted into an equivalent DFA.
            </div>  
            The theorem only says both NFA and DFA can recognize <strong>the same class of languages</strong>.  Normally, the NFA is smaller 
            and easier to understand than its equivalent DFA. So, we cannot treat them equivalently in terms of convenience.
            </p>
            </section>

            <section id="r_exp" class="section-content">
            <h2>Regular Expressions</h2>
            <p>
            \(R\) is a <strong>regular expression</strong> over the alphabet \(\Sigma\) if \(R\) is one of the following:
            <ul style="padding-left: 40px;">
                <li>\(a \in \Sigma\)</li>
                <li>\(\epsilon\)</li>
                Note: This is the language containing the empty string.
                <li>\(\emptyset\)</li>
                Note: This is the language that does not contain any strings.
                <li>\((R_1 \cup R_2)\)</li>
                <li>\((R_1 \circ R_2)\)</li>
                <li>\((R_1^*)\)</li>
            </ul>
            where \(R_1\) and \(R_2\) are regular expressions and these are smaller than \(R\). 
            <br><br>
            A language can be described by regular expressions is indeed, a FA-recognizable language. This is why 
            such a language is called a <strong>regular language</strong>. To distinguish between \(R\) and the language 
            that it describes, we write \(L(R)\) to be the language of \(R\).
            <div class="theorem">
                <span class="theorem-title">Theorem 3: </span>
                A language is regular if and only if some regular expression describes it.
                So, 
                <ol style="padding-left: 40px;">
                    <li> If a language is described by a regular exression, then it is regular.</li>
                    <li> If a language is regular, then it is described by a regular expression.</li>
                </ol>
            </div> 
            <div class="proof">
                <span class="proof-title">Proof: Part 1</span> 
                For each case in the definition, we want to convert regular expression \(R\) into NFA \(M\) recognizing some 
                language because we know that if an NFA recognizes the language, then it is regular. 
                <ol style="padding-left: 40px;">
                    <li>\(R = a\) for some \(a \in \Sigma\)</li>
                    Then 
                    \[
                    L(R) = \{a\}
                    \]
                    and the following NFA recognizes \(L(R)\):
                    \[
                    M = (\{q_0 , q_1\}, \Sigma, \delta, q_0, \{q_1\})
                    \]
                    where \(\delta(q_0, a) = \{q_1\}\) and \(\delta(r, b) = \emptyset\) for \(r \neq q_0\) or \(b \neq a\).
                    <li>\(R =\epsilon\)</li>
                    Then
                    \[
                    L(R) = \{\epsilon\}
                    \]
                    and the following NFA recognizes \(L(R)\):
                    \[
                    M = (\{q_0\}, \Sigma, \delta, q_0, \{q_0\})
                    \]
                    where \(\delta(r, b) = \emptyset\) for any \(r\) and \(b\).
                    <li>\(R = \emptyset\)</li>
                    Then 
                    \[
                    L(R) = \emptyset
                    \]
                    and the following NFA recognizes \(L(R)\):
                    \[
                    M = (\{q\}, \Sigma, \delta, q, \emptyset)
                    \]
                    where \(\delta(r, b) = \emptyset\) for any \(r\) and \(b\).
                    <div style="text-align: center;">
                        <img src="Images/P1_case1_2_3.jpg" alt="Case 1, 2, and 3"  class="responsive-image">
                    </div>
                    <br><br>
                    For case 4, 5, and 6, let \(M_1 = (Q_1, \Sigma, \delta_1, q_{0_1}, F_1) \) be the NFA recognizes \(L(R_1)\) and 
                    \(M_2 = (Q_2, \Sigma, \delta_2, q_{0_2}, F_2) \) be the NFA recognizes \(L(R_2)\). Also, we assume that the state sets 
                    \(Q_1\) and \(Q_2\) are disjoint. 
                    <li>\(R = (R_1 \cup R_2)\)</li>
                    Then
                    \[
                     L(R) = (R_1 \cup R_2)
                     \]
                     and the following NFA recognizes \(L(R)\):
                     \[
                     M = ( Q_1 \cup Q_2 \cup \{q_0\}, \Sigma, \delta, q_0, F_1 \cup F_2) 
                     \]
                     where for any \(q \in Q\) and any \(a \in \Sigma_{\epsilon}\),
                     \[
                     \delta(q, a) =  \begin{cases}
                                     \delta_1(q, a) &\text{if \(q \in Q_1\)}, \\

                                     \delta_2(q, a) &\text{if \(q \in Q_2\)}, \\

                                     \{q_{0_1}, q_{0_2}\} &\text{if \(q = q_0\) and \(a = \epsilon\)}, \\

                                     \emptyset  &\text{if \(q = q_0\) and \(a \neq \epsilon\)}. \\

                                    \end{cases}
                     \]
                     <div style="text-align: center;">
                        <img src="Images/P1_case4.jpg" alt="Case 4"  class="responsive-image">
                    </div>
                    <li>\(R = (R_1 \circ R_2)\)</li>
                    Then
                    \[
                    L(R) = (R_1 \circ R_2)
                    \]
                    and the following NFA recognizes \(L(R)\):
                    \[
                    M = ( Q_1 \cup Q_2 , \Sigma, \delta, {q_0}_1, F_2) 
                    \]
                    where for any \(q \in Q\) and any \(a \in \Sigma_{\epsilon}\).
                    \[
                    \delta(q, a) =  \begin{cases}
                                    \delta_1(q, a) &\text{if \(q \in Q_1\) and \(q \not\in F_1\) }, \\
                                    \delta_1(q, a) &\text{if \(q \in F_1\) and \(a \neq \epsilon\) }, \\
                                    \delta_1(q, a) \cup \{q_{0_2}\} &\text{if \(q \in F_1\) and \(a = \epsilon\) } \\
                                    \delta_2(q, a) &\text{if \(q \in Q_2\) }. \\
                                   \end{cases}
                    \]
                    <div style="text-align: center;">
                        <img src="Images/P1_case5.jpg" alt="Case 5"  class="responsive-image">
                    </div>
                    <li>\(R = (R_1^*) \)</li>
                    Then
                    \[
                    L(R) = (R_1^*)
                    \]
                    and the following NFA recognizes \(L(R)\):
                    \[
                     M = ( Q_1 \cup \{q_0\}, \Sigma, \delta, q_0, \{q_0\} \cup F_1) 
                     \]
                     where for any \(q \in Q\) and any \(a \in \Sigma_{\epsilon}\),
                     \[
                    \delta(q, a) =  \begin{cases}
                                    \delta_1(q, a) &\text{if \(q \in Q_1\) and \(q \not\in F_1\) } \\
                                    \delta_1(q, a) &\text{if \(q \in F_1\) and \(a \neq \epsilon\) }, \\
                                    \delta_1(q, a) \cup \{q_{0_1}\} &\text{if \(q \in F_1\) and \(a = \epsilon\) }, \\
                                    \{q_{0_1}\} &\text{if \(q = q_0\) and \(a = \epsilon\) }, \\
                                    \emptyset &\text{if \(q=q_0\) and \(a \neq \epsilon\)}. \\
                                   \end{cases}
                    \]
                    <div style="text-align: center;">
                        <img src="Images/P1_case6.jpg" alt="Case 6"  class="responsive-image">
                    </div>
                </ol>
            </div>
            Here, for example, we convert a regular expression \((01 \cup 1)^*\) into an NFA in a sequence of stage. This expression generates strings such as 
            \[
            \{\epsilon, \, 01, \, 1, \, 0101, \, 11, \, 1101, \, 01011101, \, 11111, \, 01101011110111, \, \cdots\}
            \] 
            and the following NFA recognizes these strings. When the NFA follows an \(\epsilon\)-transition, it moves to the next state without reading 
            the next symbol from the input string. 
            <div style="text-align: center;">
                <img src="Images/NFA_from_RE.jpg" alt="NFA from Regular Expression"  class="responsive-image">
            </div>
            </p>
            </section>
        </div>
        <script src="/js/main.js"></script>
    </body>
</html>

    
    <footer>
    <div class="footer-content">
        <div class="footer-about">
            <h3>About MATH-CS COMPASS</h3>
            <p>Bridging the gap between pure mathematics and computer science applications.</p>
            <div class="contact-section">
                <strong><a href="https://docs.google.com/forms/d/e/1FAIpQLSf3_RNkegREvfCEIQznn6SCaf-iB5c-Doxn7Ymuu78Uf-PBjg/viewform" target="_blank">
                    Submit Your Questions & Feedback <i class="fas fa-external-link-alt"></i>
                </a></strong>
            </div>
        </div>
        <div class="footer-links">
            <h3>Quick Links</h3>
            <ul>
                
                <li><a href="../../../index.html">Home</a></li>
                <li>
                <a href="../Linear_algebra/linear_algebra.html">
                    <span class="nav-number">I</span>
                    <span>Linear Algebra to Algebraic Foundations</span>
                </a>
                </li>
                <li>
                <a href="../Calculus/calculus.html">
                    <span class="nav-number">II</span>
                    <span>Calculus to Optimization & Analysis</span>
                </a>
                </li>
                <li>
                <a href="../Probability/probability.html">
                    <span class="nav-number">III</span>
                    <span>Probability & Statistics</span>
                </a>
                </li>
                <li>
                <a href="../Discrete/discrete_math.html">
                    <span class="nav-number">IV</span>
                    <span>Discrete Mathematics & Algorithms</span>
                </a>
                </li>
                <li>
                <a href="../Machine_learning/ml.html">
                    <span class="nav-number">V</span>
                    <span>Machine Learning</span>
                </a>
                </li>
            </ul>
        </div>
        <div class="footer-social">
            <h3>Connect With Me</h3>
            <p>
                <a href="https://x.com/MathCSCompass?t=Zi8nyfzszeFw8QizbJwnNg&s=09" target="_blank">
                    <i class="fab fa-x-twitter"></i> X (Twitter)
                </a>
            </p>
            <p>
                <a href="https://www.facebook.com/share/15uPaBWgQN/" target="_blank">
                    <i class="fab fa-facebook"></i> Facebook
                </a>
            </p>
      
            <h3>MATH-CS COMPASS App</h3>
            <div class="app-download-footer">
                <a href="https://play.google.com/store/apps/details?id=io.github.yusukey01.twa" target="_blank" rel="noopener">
                    <img src="../../../images/google-play-badge.png" 
                        alt="Get it on Google Play" 
                        class="google-play-badge">
                </a>
            </div>
            
        </div>

    </div>
    <div class="footer-bottom">
        <p>&copy; 2024-2025 MATH-CS COMPASS. All rights reserved.</p>
    </div>
</footer>
    <script src="../../../js/main.js?v=1.0.2"></script>
    <script src="../../../js/search.js?v=1.0.2"></script>
    

    <button id="go-to-top-btn" class="go-to-top-btn" title="Go to top">
        <i class="fas fa-arrow-up"></i>
    </button>
    <script>
        // Register the service worker
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('/js/service-worker.js')
              .then(registration => {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
              })
              .catch(error => {
                console.log('ServiceWorker registration failed: ', error);
              });
          });
        }
      </script>
</body>
</html>