<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Math-CS Compass | Knowledge Map</title>
    <style>
        :root { 
            --bg-color: #0b0e14; 
            --text-color: #e0e0e0; 
        }

        /* Essential Mobile Styling */
        html, body { 
            margin: 0; 
            padding: 0;
            width: 100%; 
            height: 100%;
            background: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            -webkit-text-size-adjust: 100%; 
            position: fixed; 
        }

        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
            image-rendering: -webkit-optimize-contrast;
        }

        /* UI Overlay */
        #ui-layer { 
            position: absolute; 
            top: env(safe-area-inset-top, 20px); 
            left: 20px; 
            pointer-events: none; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); 
            z-index: 10; 
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            left: 20px;
            background: rgba(11, 14, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: auto;
        }

        #legend h4 {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            color: #fff;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--text-color);
        }

        /* Home button */
        #home-btn {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            background: rgba(11, 14, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 10px 16px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            z-index: 10;
            transition: all 0.2s;
        }

        #home-btn:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }

        @media (max-width: 768px) {
            #legend {
                font-size: 0.7rem;
                padding: 8px 12px;
            }
            #legend h4 {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1 style="margin:0; font-size: 1.2rem;">MATH-CS COMPASS</h1>
    <div id="status" style="font-size: 0.9rem; opacity: 0.8;">Explore the Knowledge Map</div>
</div>

<a id="home-btn" href="/index.html">← Back to Home</a>

<div id="legend">
    <h4>Sections</h4>
    <div class="legend-item">
        <div class="legend-color" style="background: #1565c0;"></div>
        <span>I - Linear Algebra</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #2e7d32;"></div>
        <span>II - Calculus</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #c62828;"></div>
        <span>III - Probability</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #6a1b9a;"></div>
        <span>IV - Discrete Math</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #ef6c00;"></div>
        <span>V - Machine Learning</span>
    </div>
</div>

<div id="loading">Loading curriculum data...</div>

<canvas id="mapCanvas"></canvas>

<script>
/**
 * MATH-CS COMPASS: HEXAGONAL KNOWLEDGE MAP SYSTEM
 * @author Yusuke Yokota
 * @version 5.0.0 (January 2026)
 * 
 * Now imports from centralized curriculum.json for single source of truth.
 * 
 * Technical Specs:
 * - Cube Coordinates (q, r, s) where q+r+s=0
 * - LOD (Level of Detail) rendering
 * - Sequential Path Highlighting with prerequisite connections
 * - Dynamic data loading from curriculum.json
 */

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

// State
let scale = 60;
const minScale = 20, maxScale = 150;
let offsetX = 0, offsetY = 0;
let activeTileId = null;
let blinkTileId = null; 
let blinkStartTime = 0;
let isTouchInteraction = false;
let isDragging = false;
let startX = 0, startY = 0;
let lastX = 0, lastY = 0;
let initialPinchDist = 0;
let initialScale = 0;

// Data (loaded from curriculum.json)
let knowledgeData = [];
let SECTION_COLORS = {};

// Animation settings
const IDLE_BLINK_DURATION = 5000; 
const IDLE_BLINK_CHANCE = 0.005;  
const idleBlinkState = {};

/**
 * Load curriculum data from JSON file
 */
async function loadCurriculumData() {
    try {
        // Try relative path first (for local testing), then absolute
        let response;
        try {
            response = await fetch('../data/curriculum.json');
            if (!response.ok) throw new Error('Relative path failed');
        } catch {
            response = await fetch('/data/curriculum.json');
        }
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        
        // Extract section colors
        SECTION_COLORS = data.sectionColors || {};
        SECTION_COLORS['HOME'] = '#888888'; // Gray for home
        
        // Build knowledge data array
        knowledgeData = [];
        
        // Add home node
        if (data.homeNode) {
            knowledgeData.push({
                id: data.homeNode.id,
                section: 'HOME',
                title: data.homeNode.title,
                url: data.homeNode.url,
                q: data.homeNode.mapCoords.q,
                r: data.homeNode.mapCoords.r,
                prereqs: []
            });
        }
        
        // Add all parts from all sections
        Object.entries(data.sections).forEach(([sectionId, section]) => {
            section.parts.forEach(part => {
                knowledgeData.push({
                    id: part.id,
                    section: sectionId,
                    title: part.title,
                    // URL relative to map folder
                    url: '../' + section.baseUrl + part.url,
                    q: part.mapCoords.q,
                    r: part.mapCoords.r,
                    seqGroup: sectionId,
                    prereqs: part.prereqs || []
                });
            });
        });
        
        console.log(`Loaded ${knowledgeData.length} tiles from curriculum data`);
        
        // Hide loading indicator
        document.getElementById('loading').style.display = 'none';
        
        return true;
    } catch (error) {
        console.error('Failed to load curriculum data:', error);
        document.getElementById('loading').textContent = 'Error loading data. Please refresh.';
        return false;
    }
}

function setup() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.scale(dpr, dpr);
    if (offsetX === 0) { 
        offsetX = window.innerWidth / 2; 
        offsetY = window.innerHeight / 2; 
    }
}

function getPixelCoords(q, r) {
    const x = scale * Math.sqrt(3) * (q + r/2);
    const y = scale * (3/2 * r); 
    return { x: x + offsetX, y: y + offsetY };
}

function drawHexagon(x, y, size, color, alpha = 1, isGlow = false, isBlinking = false, isIdleBlinking = false) {
    ctx.save();
    let finalAlpha = alpha;

    if (isBlinking) {
        finalAlpha = 0.3 + Math.abs(Math.sin(Date.now() / 800)) * 0.7;
    } else if (isIdleBlinking) {
        if (idleBlinkState[isIdleBlinking] !== undefined) {
            const elapsed = Date.now() - idleBlinkState[isIdleBlinking];
            const progress = elapsed / IDLE_BLINK_DURATION;
            finalAlpha = 0.8 + 0.2 * Math.sin(progress * Math.PI * 2 - Math.PI / 2);
        }
    }

    ctx.globalAlpha = finalAlpha;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 6) + (i * Math.PI / 3);
        ctx.lineTo(x + size * Math.cos(angle), y + size * Math.sin(angle));
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();

    if (isGlow || isBlinking || isIdleBlinking) {
        ctx.strokeStyle = isIdleBlinking ? "rgba(255,255,255,0.5)" : "white"; 
        ctx.lineWidth = isIdleBlinking ? 2 : 3; 
        ctx.shadowBlur = isIdleBlinking ? 5 : 15; 
        ctx.shadowColor = "white"; 
        ctx.stroke();
    } else {
        ctx.strokeStyle = "rgba(255,255,255,0.15)"; 
        ctx.lineWidth = 1; 
        ctx.stroke();
    }
    ctx.restore();
}

function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '', lines = [];
    for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        if (ctx.measureText(testLine).width > maxWidth && n > 0) { 
            lines.push(line); 
            line = words[n] + ' '; 
        } else { 
            line = testLine; 
        }
    }
    lines.push(line);
    const startY = y - ((lines.length - 1) * lineHeight) / 2;
    lines.forEach((l, i) => ctx.fillText(l.trim(), x, startY + (i * lineHeight)));
}

/**
 * Draw prerequisite connections as curved lines
 */
function drawPrerequisiteConnections(activeTile) {
    if (!activeTile || !activeTile.prereqs || activeTile.prereqs.length === 0) return;
    
    const activeCoords = getPixelCoords(activeTile.q, activeTile.r);
    
    activeTile.prereqs.forEach(prereqId => {
        const prereq = knowledgeData.find(t => t.id === prereqId);
        if (!prereq) return;
        
        const prereqCoords = getPixelCoords(prereq.q, prereq.r);
        
        // Draw curved connection line
        ctx.save();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        // Calculate control point for curve
        const midX = (activeCoords.x + prereqCoords.x) / 2;
        const midY = (activeCoords.y + prereqCoords.y) / 2;
        const dx = activeCoords.x - prereqCoords.x;
        const dy = activeCoords.y - prereqCoords.y;
        const perpX = -dy * 0.2;
        const perpY = dx * 0.2;
        
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(midX + perpX, midY + perpY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        
        // Draw arrow head
        const angle = Math.atan2(activeCoords.y - (midY + perpY), activeCoords.x - (midX + perpX));
        const arrowSize = 10;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(activeCoords.x, activeCoords.y);
        ctx.lineTo(
            activeCoords.x - arrowSize * Math.cos(angle - Math.PI/6),
            activeCoords.y - arrowSize * Math.sin(angle - Math.PI/6)
        );
        ctx.moveTo(activeCoords.x, activeCoords.y);
        ctx.lineTo(
            activeCoords.x - arrowSize * Math.cos(angle + Math.PI/6),
            activeCoords.y - arrowSize * Math.sin(angle + Math.PI/6)
        );
        ctx.stroke();
        
        ctx.restore();
    });
}

function render() {
    if (knowledgeData.length === 0) {
        requestAnimationFrame(render);
        return;
    }
    
    const time = Date.now();
    const globalAlphaFactor = 0.97 + 0.03 * Math.sin(time / 2500);
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.globalAlpha = globalAlphaFactor;

    const activeTile = activeTileId ? knowledgeData.find(t => t.id === activeTileId) : null;
    if (blinkTileId && Date.now() - blinkStartTime > 3000) blinkTileId = null;

    const isSystemIdle = !activeTileId && !blinkTileId;

    // Draw prerequisite connections first (behind tiles)
    if (activeTile) {
        drawPrerequisiteConnections(activeTile);
    }

    // Draw tiles
    knowledgeData.forEach(tile => {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        let alpha = activeTile ? 0.15 : 1.0;
        let glow = false;
        
        let isIdleBlinking = false;
        if (isSystemIdle) {
            if (idleBlinkState[tile.id]) {
                const elapsed = time - idleBlinkState[tile.id];
                if (elapsed < IDLE_BLINK_DURATION) {
                    isIdleBlinking = tile.id;
                } else {
                    delete idleBlinkState[tile.id];
                }
            } else if (Math.random() < IDLE_BLINK_CHANCE) {
                idleBlinkState[tile.id] = time;
            }
        } else {
            delete idleBlinkState[tile.id];
        }

        if (activeTile) {
            const isSelf = tile.id === activeTileId;
            const isSeq = activeTile.seqGroup && tile.seqGroup === activeTile.seqGroup;
            const isPrereq = activeTile.prereqs && activeTile.prereqs.includes(tile.id);
            
            if (isSelf || isSeq || isPrereq) { 
                alpha = 1.0; 
                glow = isSelf || isPrereq; 
            }
        }

        const color = SECTION_COLORS[tile.section] || '#888888';
        drawHexagon(x, y, scale * 0.95, color, alpha, glow, tile.id === blinkTileId, isIdleBlinking);
        
        // Draw text
        if (scale > 30 && (alpha > 0.5 || tile.id === blinkTileId)) {
            ctx.fillStyle = "white"; 
            ctx.textAlign = "center";
            const fontSize = Math.max(scale / 4.5, 12);
            ctx.font = `bold ${fontSize}px 'Segoe UI', sans-serif`;
            wrapText(tile.title, x, y, scale * 1.5, fontSize * 1.2);
        }
    });
    
    // UI Hint for selected tile
    if (activeTile) {
        const { x, y } = getPixelCoords(activeTile.q, activeTile.r);
        ctx.fillStyle = "#ffffff";
        ctx.font = "12px sans-serif";
        ctx.fillText("▼ Tap again to Open", x, y + scale * 0.85);
        
        // Show prerequisite count
        if (activeTile.prereqs && activeTile.prereqs.length > 0) {
            ctx.fillStyle = "rgba(255,255,255,0.7)";
            ctx.fillText(`Prerequisites: ${activeTile.prereqs.length}`, x, y - scale * 0.85);
        }
    }

    requestAnimationFrame(render);
}

// --- INTERACTION LOGIC ---

function handleInteraction(clientX, clientY) {
    if (isDragging) return;

    let hit = false;
    for (const tile of knowledgeData) {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        if (Math.hypot(x - clientX, y - clientY) < scale * 0.8) {
            hit = true;
            if (activeTileId === tile.id) {
                // Second tap: navigate
                window.location.assign(tile.url);
            } else {
                // First tap: select
                activeTileId = tile.id;
                const prereqCount = tile.prereqs?.length || 0;
                const prereqText = prereqCount > 0 ? ` (${prereqCount} prerequisites)` : '';
                document.getElementById('status').innerText = `Selected: ${tile.title}${prereqText}`;
            }
            break;
        }
    }
    if (!hit) {
        activeTileId = null;
        document.getElementById('status').innerText = "Explore the Knowledge Map";
    }
}

// Mouse Handlers
window.addEventListener('mousedown', e => { 
    if (isTouchInteraction) return; 
    isDragging = false; 
    startX = e.clientX; startY = e.clientY; 
    lastX = e.clientX; lastY = e.clientY;
});

window.addEventListener('mousemove', e => {
    if (isTouchInteraction) return;
    if (e.buttons === 1) {
        if (Math.hypot(e.clientX - startX, e.clientY - startY) > 5) isDragging = true;
        if (isDragging) { 
            offsetX += e.clientX - lastX; 
            offsetY += e.clientY - lastY; 
        }
        lastX = e.clientX; lastY = e.clientY;
    }
});

window.addEventListener('mouseup', e => {
    if (isTouchInteraction) return;
    if (!isDragging) handleInteraction(e.clientX, e.clientY);
});

window.addEventListener('wheel', e => {
    scale = Math.min(Math.max(minScale, scale - e.deltaY * 0.05), maxScale);
}, { passive: false });

// Touch Handlers
canvas.addEventListener('touchstart', e => {
    isTouchInteraction = true; 
    if (e.touches.length === 1) {
        isDragging = false;
        startX = e.touches[0].clientX; startY = e.touches[0].clientY;
        lastX = startX; lastY = startY;
    } else if (e.touches.length === 2) {
        initialPinchDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX, 
            e.touches[0].clientY - e.touches[1].clientY
        );
        initialScale = scale;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        if (Math.hypot(x - startX, y - startY) > 5) isDragging = true;
        offsetX += x - lastX; offsetY += y - lastY;
        lastX = x; lastY = y;
    } else if (e.touches.length === 2) {
        const dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX, 
            e.touches[0].clientY - e.touches[1].clientY
        );
        if (initialPinchDist > 0) {
            scale = Math.min(Math.max(minScale, initialScale * (dist / initialPinchDist)), maxScale);
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault(); 
    if (!isDragging && e.changedTouches.length === 1) {
        handleInteraction(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
    setTimeout(() => isTouchInteraction = false, 500); 
});

// Keyboard navigation
window.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        activeTileId = null;
        document.getElementById('status').innerText = "Explore the Knowledge Map";
    }
    if (e.key === 'Enter' && activeTileId) {
        const tile = knowledgeData.find(t => t.id === activeTileId);
        if (tile) window.location.assign(tile.url);
    }
});

// Initialize
window.addEventListener('resize', setup);

async function init() {
    setup();
    const loaded = await loadCurriculumData();
    if (loaded) {
        render();
    }
}

init();
</script>
</body>
</html>