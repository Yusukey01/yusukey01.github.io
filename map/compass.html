<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Math-CS Compass | Knowledge Map</title>
    <style>
        :root { 
            --bg-color: #0b0e14; 
            --text-color: #e0e0e0;
            --glass-bg: rgba(15, 20, 30, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-glow: rgba(100, 180, 255, 0.3);
        }

        /* Essential Mobile Styling */
        html, body { 
            margin: 0; 
            padding: 0;
            width: 100%; 
            height: 100%;
            background: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            -webkit-text-size-adjust: 100%; 
            position: fixed; 
        }

        /* Subtle animated background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(30, 60, 100, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(60, 30, 80, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: bgPulse 20s ease-in-out infinite;
        }

        @keyframes bgPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
            image-rendering: -webkit-optimize-contrast;
            position: relative;
            z-index: 1;
        }

        /* Glassmorphism UI Elements */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* UI Overlay */
        #ui-layer { 
            position: absolute; 
            top: env(safe-area-inset-top, 20px); 
            left: 20px; 
            pointer-events: none; 
            z-index: 10;
        }

        #ui-layer h1 {
            margin: 0;
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 2px;
            background: linear-gradient(135deg, #fff 0%, #a0c4ff 50%, #fff 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s linear infinite;
        }

        @keyframes shimmer {
            to { background-position: 200% center; }
        }

        #status {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 4px;
            transition: all 0.3s ease;
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            left: 20px;
            padding: 14px 18px;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: auto;
            transform: translateY(0);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #legend:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #legend h4 {
            margin: 0 0 10px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: #fff;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding-bottom: 8px;
            letter-spacing: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            padding: 4px 6px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .legend-item:hover .legend-color {
            transform: scale(1.2);
            box-shadow: 0 0 12px currentColor;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid rgba(255,255,255,0.3);
            transition: all 0.2s ease;
        }

        .legend-item span {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--text-color);
            z-index: 100;
        }

        #loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            margin-left: 12px;
            vertical-align: middle;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Home button with micro-interactions */
        #home-btn {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            padding: 12px 20px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 10;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        #home-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        #home-btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(52, 152, 219, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: rgba(52, 152, 219, 0.5);
        }

        #home-btn:hover::before {
            left: 100%;
        }

        #home-btn:active {
            transform: translateY(0) scale(0.98);
        }

        /* Zoom Controls */
        #zoom-controls {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: 300;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
        }

        .zoom-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        /* Tessera Guide Container */
        #tessera-container {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            right: 80px;
            z-index: 15;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            pointer-events: none;
        }

        /* Speech Bubble */
        #tessera-bubble {
            max-width: 220px;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            font-size: 0.82rem;
            line-height: 1.5;
            color: var(--text-color);
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: auto;
        }

        #tessera-bubble.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        #tessera-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            right: 40px;
            width: 16px;
            height: 16px;
            background: var(--glass-bg);
            border-right: 1px solid var(--glass-border);
            border-bottom: 1px solid var(--glass-border);
            transform: rotate(45deg);
        }

        /* Tessera Character */
        #tessera-character {
            width: 180px;
            height: 180px;
            position: relative;
            cursor: pointer;
            pointer-events: auto;
            animation: tesseraFloat 3s ease-in-out infinite;
        }

        #tessera-character img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.5s ease;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4));
        }

        #tessera-character img.active {
            opacity: 1;
        }

        @keyframes tesseraFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        /* Wave animation on load */
        @keyframes tesseraWave {
            0% { transform: translateY(20px) scale(0.8); opacity: 0; }
            50% { transform: translateY(-10px) scale(1.05); }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        #tessera-character.entering {
            animation: tesseraWave 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        #tessera-character.entering img.active {
            opacity: 1;
        }

        /* Tessera name tag */
        #tessera-name {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin-top: 4px;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #tessera-container:hover #tessera-name {
            opacity: 1;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            #tessera-container {
                right: 70px;
                bottom: env(safe-area-inset-bottom, 15px);
            }
            #tessera-character {
                width: 110px;
                height: 110px;
            }
            #tessera-bubble {
                max-width: 180px;
                font-size: 0.75rem;
                padding: 10px 12px;
            }
        }

        @media (max-width: 480px) {
            #tessera-container {
                right: 60px;
            }
            #tessera-character {
                width: 90px;
                height: 90px;
            }
            #tessera-bubble {
                max-width: 150px;
            }
        }

        /* Search Bar with expanding focus */
        #search-container {
            position: absolute;
            top: env(safe-area-inset-top, 40px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        #search-input {
            width: 200px;
            padding: 10px 16px;
            font-size: 0.9rem;
            color: var(--text-color);
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            outline: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        #search-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        #search-input:focus {
            width: 280px;
            border-color: rgba(100, 180, 255, 0.5);
            box-shadow: 
                0 4px 30px rgba(0, 0, 0, 0.3),
                0 0 20px rgba(100, 180, 255, 0.2);
        }

        /* Compact Legend - Roman Numeral Icons for ALL screen sizes */
        #legend {
            padding: 8px 10px;
            left: 10px;
        }
        #legend h4 {
            display: none;
        }
        #legend .legend-items {
            display: flex;
            flex-direction: row;
            gap: 6px;
        }
        .legend-item {
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 4px;
        }
        .legend-item span.legend-label {
            display: none;
        }
        .legend-color {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            margin-right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .legend-numeral {
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }

        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            #search-input {
                width: 160px;
            }
            #search-input:focus {
                width: 220px;
            }
            #zoom-controls {
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            #search-container {
                left: 70px;
                transform: none;
            }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>MATH-CS COMPASS</h1>
    <div id="status">Explore the Knowledge Map</div>
</div>

<div id="search-container">
    <input type="text" id="search-input" placeholder="Search topics..." autocomplete="off">
</div>

<a id="home-btn" class="glass-panel" href="/index.html">← Home</a>

<div id="legend" class="glass-panel">
    <h4>Sections</h4>
    <div class="legend-items">
        <div class="legend-item" data-section="I">
            <div class="legend-color" style="background: #1565c0; color: #1565c0;">
                <span class="legend-numeral">I</span>
            </div>
            <span class="legend-label">I - Linear Algebra to Algebraic Foundations</span>
        </div>
        <div class="legend-item" data-section="II">
            <div class="legend-color" style="background: #2e7d32; color: #2e7d32;">
                <span class="legend-numeral">II</span>
            </div>
            <span class="legend-label">II - Calculus to Optimization & Analysis</span>
        </div>
        <div class="legend-item" data-section="III">
            <div class="legend-color" style="background: #00838f; color: #00838f;">
                <span class="legend-numeral">III</span>
            </div>
            <span class="legend-label">III - Probability & Statistics</span>
        </div>
        <div class="legend-item" data-section="IV">
            <div class="legend-color" style="background: #6a1b9a; color: #6a1b9a;">
                <span class="legend-numeral">IV</span>
            </div>
            <span class="legend-label">IV - Discrete Mathematics & Algorithms</span>
        </div>
        <div class="legend-item" data-section="V">
            <div class="legend-color" style="background: #ef6c00; color: #ef6c00;">
                <span class="legend-numeral">V</span>
            </div>
            <span class="legend-label">V - Machine Learning</span>
        </div>
    </div>
</div>

<div id="zoom-controls">
    <div class="zoom-btn glass-panel" id="zoom-in">+</div>
    <div class="zoom-btn glass-panel" id="zoom-out">−</div>
</div>

<!-- Tessera Guide -->
<div id="tessera-container">
    <div id="tessera-bubble">
        <span id="tessera-message">Welcome to MATH-CS COMPASS! Click any hexagon to explore.</span>
    </div>
    <div id="tessera-character" class="entering">
        <img id="tessera-wave" src="../images/tessera/tessera_wave.png" alt="Tessera waving" class="active">
        <img id="tessera-idle" src="../images/tessera/tessera_idle.png" alt="Tessera thinking">
        <img id="tessera-frustrated" src="../images/tessera/tessera_frustrated.png" alt="Tessera frustrated">
        <img id="tessera-excited" src="../images/tessera/tessera_excited.png" alt="Tessera excited">
        <img id="tessera-confident" src="../images/tessera/tessera_confident.png" alt="Tessera confident">
        <img id="tessera-proud" src="../images/tessera/tessera_proud.png" alt="Tessera proud">
        <img id="tessera-surprised" src="../images/tessera/tessera_surprised.png" alt="Tessera surprised">
        <img id="tessera-calm" src="../images/tessera/tessera_calm.png" alt="Tessera calm">
        <img id="tessera-worried" src="../images/tessera/tessera_worried.png" alt="Tessera worried">
        <img id="tessera-laughing" src="../images/tessera/tessera_laughing.png" alt="Tessera laughing">
        <img id="tessera-shocked" src="../images/tessera/tessera_shocked.png" alt="Tessera shocked">
    </div>
    <div id="tessera-name">TESSERA</div>
</div>

<div id="loading">Loading curriculum data</div>

<canvas id="mapCanvas"></canvas>

<script>
/**
 * MATH-CS COMPASS: HEXAGONAL KNOWLEDGE MAP SYSTEM
 * @author Yusuke Yokota
 * @version 6.0.1 (January 2026)
 * 
 * Enhanced with professional animations:
 * - Animated prerequisite flows with particles
 * - Entry animations with staggered cascade
 * - Enhanced hover states with glow and depth
 * - Glassmorphism UI
 * - Micro-interactions throughout
 * - Section highlighting from legend clicks
 */

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

// State
let scale = 50; // Start zoomed out to show full map and entry animation
const minScale = 40, maxScale = 250;
let offsetX = window.innerWidth / 2;
let offsetY = window.innerHeight / 2;

// Camera animation state
let targetOffsetX = offsetX;
let targetOffsetY = offsetY;
let isPanning = false;

// Tile animation
let activeTileId = null;
let hoveredTileId = null;
let blinkTileId = null; 
let blinkStartTime = 0;
let isTouchInteraction = false;
let isDragging = false;
let startX = 0, startY = 0;
let lastX = 0, lastY = 0;
let initialPinchDist = 0;
let initialScale = 0;

// Data (loaded from curriculum.json)
let knowledgeData = [];
let SECTION_COLORS = {};

// Entry Animation State
let entryAnimationActive = true;
let entryAnimationStartTime = 0;
const ENTRY_ANIMATION_DURATION = 1500; // Total duration for all tiles to appear
const ENTRY_STAGGER_DELAY = 30; // ms between each tile appearing
const ENTRY_TILE_DURATION = 600; // Duration for each tile's individual animation

// Exit Animation State (reverse of entry)
let exitAnimationActive = false;
let exitAnimationStartTime = 0;
let exitTargetUrl = null;
const EXIT_STAGGER_DELAY = 10; // ms between each tile disappearing
const EXIT_TILE_DURATION = 300; // Duration for each tile's individual animation

// Hover Animation State
const hoverState = {};

// Prerequisite Animation State
const prereqAnimState = {
    particles: [],
    lastSpawnTime: 0
};

// Animation settings
const IDLE_BLINK_DURATION = 4000;
const IDLE_BLINK_INTERVAL = 2500;
const MAX_CONCURRENT_BLINKS = 4;
const idleBlinkState = {};
let lastBlinkTime = 0;

const panSpeed = 0.12;

// Search state
let searchQuery = '';
let searchResults = [];

// Section highlight state (for legend clicks)
let highlightedSection = null;
let highlightedSectionTime = 0;
const SECTION_HIGHLIGHT_DURATION = 3000; // How long the highlight lasts

// Tessera Guide State
const tesseraState = {
    currentExpression: 'wave', // 'wave', 'idle', 'frustrated', 'excited', 'confident', 'surprised', 'calm', 'laughing, 'shocked'
    isInitialized: false,
    bubbleTimeout: null,
    lastTileId: null,
    clickCount: 0, // Track consecutive clicks on Tessera
    lastClickTime: 0, // To reset click count after inactivity
    showingSectionExplain: false // Prevent idle messages from overriding section explanations
};

// Tessera click reactions (progressive teasing)
const tesseraClickReactions = [
    { expression: 'excited', message: "Oh! Need a tip? Try clicking the legend to explore sections!" },
    { expression: 'confident', message: "I've organized all these topics for you. Take your time!" },
    { expression: 'proud', message: () => `${knowledgeData.filter(t => !t.isReserved && t.id !== 'home').length} topics and counting! I'm quite proud of this map.` },
    { expression: 'surprised', message: "Wow, you really like clicking me! I'm Tessera, your guide." },
    { expression: 'calm', message: "Just browsing? That's okay, I'll be here when you need me." },
    { expression: 'laughing', message: "H-hey! That tickles!" },
    { expression: 'frustrated', message: "Okay okay, I get it! Go explore the map already!" }
];

// Default Tessera messages (can be overridden by curriculum.json tesseraMessage field)
const tesseraDefaultMessages = {
    welcome: "Welcome to MATH-CS COMPASS! Click any hexagon to explore.",
    idle: [
        "Take your time exploring the map!",
        "Each hexagon is a piece of the puzzle.",
        "Follow the connections to see how topics relate.",
        "Hover over tiles to see their names.",
        "Click a tile twice to open its page!"
    ],
    reserved: "I'm still preparing this topic... check back soon!",
    home: "This is the center of your journey. Everything connects here.",
    hasPrereqs: (count) => `This topic builds on ${count} prerequisite${count > 1 ? 's' : ''}. Make sure you're ready!`,
    advanced: "An advanced topic! The journey here is worth it.",
    foundational: "A great starting point for this section!"
};

// Section explanations for Tessera (triggered by legend tap)
const tesseraSectionExplanations = {
    I: {
        expression: 'confident',
        message: "Section I: Linear Algebra & Algebraic Foundations — vectors, matrices, and abstract algebra power everything from graphics to cryptography!"
    },
    II: {
        expression: 'excited',
        message: "Section II: Calculus to Optimization — gradients, integrals, and metric spaces. Essential for understanding how ML models learn!"
    },
    III: {
        expression: 'proud',
        message: "Section III: Probability & Statistics — uncertainty is everywhere! Master this to understand data and predictions."
    },
    IV: {
        expression: 'calm',
        message: "Section IV: Discrete Math & Algorithms — the heart of CS! Graphs, logic, and computational thinking."
    },
    V: {
        expression: 'surprised',
        message: "Section V: Machine Learning — where all the math comes together! Neural networks, optimization, and AI magic."
    }
};

/**
 * Load curriculum data from JSON file
 */
async function loadCurriculumData() {
    try {
        let response;
        try {
            response = await fetch('../data/curriculum.json');
            if (!response.ok) throw new Error('Relative path failed');
        } catch {
            response = await fetch('/data/curriculum.json');
        }
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        
        SECTION_COLORS = data.sectionColors || {};
        SECTION_COLORS['HOME'] = '#888888';
        
        knowledgeData = [];
        
        if (data.homeNode) {
            knowledgeData.push({
                id: data.homeNode.id,
                section: 'HOME',
                title: data.homeNode.title,
                url: data.homeNode.url,
                q: data.homeNode.mapCoords.q,
                r: data.homeNode.mapCoords.r,
                prereqs: []
            });
        }
        
        Object.entries(data.sections).forEach(([sectionId, section]) => {
            section.parts.forEach(part => {
                knowledgeData.push({
                    id: part.id,
                    section: sectionId,
                    title: part.title,
                    url: '../' + section.baseUrl + part.url,
                    q: part.mapCoords.q,
                    r: part.mapCoords.r,
                    topicGroup: part.topicGroup || null,
                    prereqs: part.prereqs || [],
                    keywords: part.keywords || [],
                    tesseraMessage: part.tesseraMessage || null
                });
            });
            
            if (section.reservedSlots) {
                section.reservedSlots.forEach((slot, index) => {
                    knowledgeData.push({
                        id: `${sectionId}-reserved-${index}`,
                        section: sectionId,
                        title: 'Coming Soon',
                        url: null,
                        q: slot.q,
                        r: slot.r,
                        topicGroup: null,
                        prereqs: [],
                        isReserved: true,
                        tesseraMessage: null
                    });
                });
            }
        });
        
        // Sort tiles by distance from center for entry animation
        knowledgeData.sort((a, b) => {
            const distA = Math.sqrt(a.q * a.q + a.r * a.r);
            const distB = Math.sqrt(b.q * b.q + b.r * b.r);
            return distA - distB;
        });
        
        console.log(`Loaded ${knowledgeData.length} tiles from curriculum data`);
        
        document.getElementById('loading').style.display = 'none';
        
        // Start entry animation
        entryAnimationStartTime = Date.now();
        
        return true;
    } catch (error) {
        console.error('Failed to load curriculum data:', error);
        document.getElementById('loading').textContent = 'Error loading data. Please refresh.';
        return false;
    }
}

/**
 * Tessera Guide System
 */
function initTessera() {
    if (tesseraState.isInitialized) return;
    
    const character = document.getElementById('tessera-character');
    const bubble = document.getElementById('tessera-bubble');
    
    // Show welcome message after entry animation
    setTimeout(() => {
        bubble.classList.add('visible');
        setTesseraExpression('wave');
        
        // Transition to idle after welcome
        setTimeout(() => {
            setTesseraExpression('idle');
            character.classList.remove('entering');
        }, 2500);
    }, 800);
    
    // Click on Tessera - progressive teasing reactions
    character.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent click from affecting map
        
        const now = Date.now();
        
        // Reset click count if more than 10 seconds since last click
        if (now - tesseraState.lastClickTime > 10000) {
            tesseraState.clickCount = 0;
        }
        
        tesseraState.lastClickTime = now;
        
        // Get reaction based on click count
        const reactionIndex = Math.min(tesseraState.clickCount, tesseraClickReactions.length - 1);
        const reaction = tesseraClickReactions[reactionIndex];
        
        // Handle message as string or function
        const message = typeof reaction.message === 'function' ? reaction.message() : reaction.message;
        
        setTesseraExpression(reaction.expression);
        updateTesseraMessage(message);
        
        // Increment click count
        tesseraState.clickCount++;
        
        // Make bubble visible if not already
        if (!bubble.classList.contains('visible')) {
            bubble.classList.add('visible');
        }
    });
    
    tesseraState.isInitialized = true;
}

// Reset Tessera to normal state (called when user interacts with tiles)
function resetTesseraState() {
    tesseraState.clickCount = 0;
}

function setTesseraExpression(expression) {
    // Get all expression images
    const expressions = {
        wave: document.getElementById('tessera-wave'),
        idle: document.getElementById('tessera-idle'),
        frustrated: document.getElementById('tessera-frustrated'),
        excited: document.getElementById('tessera-excited'),
        confident: document.getElementById('tessera-confident'),
        proud: document.getElementById('tessera-proud'),
        surprised: document.getElementById('tessera-surprised'),
        calm: document.getElementById('tessera-calm'),
        worried: document.getElementById('tessera-worried'),
        laughing: document.getElementById('tessera-laughing'),
        shocked: document.getElementById('tessera-shocked')
    };
    
    // Remove active class from all
    Object.values(expressions).forEach(img => {
        if (img) img.classList.remove('active');
    });
    
    // Set the new expression
    if (expressions[expression]) {
        expressions[expression].classList.add('active');
    } else {
        // Default to idle if expression not found
        expressions.idle.classList.add('active');
        expression = 'idle';
    }
    
    tesseraState.currentExpression = expression;
}

function updateTesseraMessage(message) {
    const messageEl = document.getElementById('tessera-message');
    const bubble = document.getElementById('tessera-bubble');
    
    // Fade out, change text, fade in
    bubble.classList.remove('visible');
    
    setTimeout(() => {
        messageEl.textContent = message;
        bubble.classList.add('visible');
    }, 200);
}

function updateTesseraForTile(tile) {
    // Reset click count when user interacts with tiles (appropriate action)
    resetTesseraState();
    
    if (!tile) {
        // No tile selected - show idle message after a delay
        // BUT only if we're not showing a section explanation
        if (tesseraState.showingSectionExplain) {
            return; // Don't override section explanation with idle
        }
        
        if (tesseraState.bubbleTimeout) {
            clearTimeout(tesseraState.bubbleTimeout);
        }
        tesseraState.bubbleTimeout = setTimeout(() => {
            if (tesseraState.showingSectionExplain) return; // Double check
            setTesseraExpression('idle');
            const idleMessages = tesseraDefaultMessages.idle;
            const randomMsg = idleMessages[Math.floor(Math.random() * idleMessages.length)];
            updateTesseraMessage(randomMsg);
        }, 1500);
        tesseraState.lastTileId = null;
        return;
    }
    
    // User selected a tile - this takes priority, clear section explain state
    tesseraState.showingSectionExplain = false;
    
    // Don't update if same tile
    if (tile.id === tesseraState.lastTileId) return;
    tesseraState.lastTileId = tile.id;
    
    // Clear any pending timeout
    if (tesseraState.bubbleTimeout) {
        clearTimeout(tesseraState.bubbleTimeout);
    }
    
    // Reserved tile - randomly frustrated or worried
    if (tile.isReserved) {
        const reservedReactions = [
            { expression: 'frustrated', message: "I'm still preparing this topic... check back soon!" },
            { expression: 'worried', message: "This section isn't ready yet... I'm working on it!" }
        ];
        const reaction = reservedReactions[Math.floor(Math.random() * reservedReactions.length)];
        setTesseraExpression(reaction.expression);
        updateTesseraMessage(reaction.message);
        return;
    }
    
    // Home tile - wave expression
    if (tile.id === 'home') {
        setTesseraExpression('confident');
        updateTesseraMessage(tesseraDefaultMessages.home);
        return;
    }

    // Custom message from curriculum.json - random expression (happy to share)
    if (tile.tesseraMessage) {
        const tileExpressions = ['wave', 'confident', 'shocked', 'proud'];
        const randomExpression = tileExpressions[Math.floor(Math.random() * tileExpressions.length)];
        setTesseraExpression(randomExpression);
        updateTesseraMessage(tile.tesseraMessage);
        return;
    }
    
    // Fallback for tiles without custom messages (shouldn't happen if curriculum.json is complete)
    setTesseraExpression('idle');
    updateTesseraMessage(`Exploring: ${tile.title}`);
}

/**
 * Trigger Tessera to explain a section when legend item is tapped
 * @param {string} section - Section ID (I, II, III, IV, V)
 */
function triggerTesseraSectionExplain(section) {
    const explanation = tesseraSectionExplanations[section];
    if (explanation) {
        // Clear any pending idle timeout so it doesn't override our message
        if (tesseraState.bubbleTimeout) {
            clearTimeout(tesseraState.bubbleTimeout);
        }
        
        setTesseraExpression(explanation.expression);
        updateTesseraMessage(explanation.message);
        
        // Make bubble visible
        const bubble = document.getElementById('tessera-bubble');
        if (bubble && !bubble.classList.contains('visible')) {
            bubble.classList.add('visible');
        }
        
        // Mark that we're showing a section explanation (prevent quick override)
        tesseraState.showingSectionExplain = true;
        tesseraState.lastTileId = null; // Reset so tile selection can still work
        
        // After a longer duration, allow idle messages again
        tesseraState.bubbleTimeout = setTimeout(() => {
            tesseraState.showingSectionExplain = false;
        }, 8000); // Keep section explanation for 8 seconds
    }
}

function setup() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.scale(dpr, dpr);
    if (offsetX === 0) { 
        offsetX = window.innerWidth / 2; 
        offsetY = window.innerHeight / 2; 
    }
}

function getPixelCoords(q, r) {
    const x = scale * Math.sqrt(3) * (q + r/2);
    const y = scale * (3/2 * r); 
    return { x: x + offsetX, y: y + offsetY };
}

/**
 * Easing functions for smooth animations
 */
const Easing = {
    easeOutCubic: t => 1 - Math.pow(1 - t, 3),
    easeOutElastic: t => {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    },
    easeOutBack: t => {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    },
    easeInBack: t => {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return c3 * t * t * t - c1 * t * t;
    },
    easeInOutQuad: t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2
};

/**
 * Calculate entry animation progress for a tile
 */
function getEntryAnimationProgress(tileIndex) {
    if (!entryAnimationActive) return 1;
    
    const elapsed = Date.now() - entryAnimationStartTime;
    const tileStartTime = tileIndex * ENTRY_STAGGER_DELAY;
    const tileElapsed = elapsed - tileStartTime;
    
    if (tileElapsed < 0) return 0;
    if (tileElapsed >= ENTRY_TILE_DURATION) return 1;
    
    return Easing.easeOutBack(tileElapsed / ENTRY_TILE_DURATION);
}

/**
 * Get exit animation progress for a tile (reverse of entry)
 * Returns 1 (fully visible) to 0 (gone)
 */
function getExitAnimationProgress(tileIndex) {
    if (!exitAnimationActive) return 1;
    
    const elapsed = Date.now() - exitAnimationStartTime;
    // Reverse order: tiles further from center disappear first
    const reversedIndex = knowledgeData.length - 1 - tileIndex;
    const tileStartTime = reversedIndex * EXIT_STAGGER_DELAY;
    const tileElapsed = elapsed - tileStartTime;
    
    if (tileElapsed < 0) return 1;
    if (tileElapsed >= EXIT_TILE_DURATION) return 0;
    
    // Use easeInBack for a "sucking in" effect (reverse of easeOutBack)
    return 1 - Easing.easeInBack(tileElapsed / EXIT_TILE_DURATION);
}

/**
 * Trigger exit animation then navigate to URL
 */
function triggerExitAnimation(url) {
    if (exitAnimationActive) return; // Already exiting
    
    exitAnimationActive = true;
    exitAnimationStartTime = Date.now();
    exitTargetUrl = url;
    
    // Update Tessera for departure
    setTesseraExpression('wave');
    updateTesseraMessage("See you there! Happy learning!");
    
    // Fade out UI elements for cleaner transition
    const uiElements = ['#ui-layer', '#search-container', '#home-btn', '#legend', '#zoom-controls'];
    uiElements.forEach(selector => {
        const el = document.querySelector(selector);
        if (el) {
            el.style.transition = 'opacity 0.4s ease-out';
            el.style.opacity = '0';
        }
    });
    
    // Calculate actual animation duration based on tile count
    const totalExitDuration = (knowledgeData.length * EXIT_STAGGER_DELAY) + EXIT_TILE_DURATION;
    
    // Fade out Tessera near the end of animation
    setTimeout(() => {
        const tessera = document.getElementById('tessera-container');
        if (tessera) {
            tessera.style.transition = 'opacity 0.3s ease-out';
            tessera.style.opacity = '0';
        }
    }, totalExitDuration - 300);
    
    // Navigate after full animation completes (with small buffer)
    setTimeout(() => {
        window.location.assign(url);
    }, totalExitDuration + 150);
}

/**
 * Draw hexagon with enhanced visuals
 */
function drawHexagon(x, y, size, color, alpha = 1, isGlow = false, isBlinking = false, isIdleBlinking = false, isReserved = false, entryProgress = 1, isHovered = false, isSearchMatch = false) {
    ctx.save();
    
    // Entry animation: scale and fade in
    const animScale = 0.3 + 0.7 * entryProgress;
    const animAlpha = entryProgress;
    
    let finalAlpha = alpha * animAlpha;
    let finalSize = size * animScale;

    // Hover effect: slight scale up and glow
    if (isHovered && !isReserved) {
        finalSize *= 1.08;
        finalAlpha = Math.min(1, finalAlpha * 1.2);
    }

    if (isBlinking) {
        finalAlpha = 0.3 + Math.abs(Math.sin(Date.now() / 2000)) * 0.7;
    } else if (isIdleBlinking) {
        if (idleBlinkState[isIdleBlinking] !== undefined) {
            const elapsed = Date.now() - idleBlinkState[isIdleBlinking];
            const progress = elapsed / IDLE_BLINK_DURATION;
            finalAlpha = 0.8 + 0.2 * Math.sin(progress * Math.PI * 2 - Math.PI / 2);
        }
    }
    
    if (isReserved) {
        finalAlpha = 0.2 * animAlpha;
    }

    // Search highlight glow
    if (isSearchMatch) {
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 25;
        finalAlpha = 1;
    }

    ctx.globalAlpha = finalAlpha;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 6) + (i * Math.PI / 3);
        ctx.lineTo(x + finalSize * Math.cos(angle), y + finalSize * Math.sin(angle));
    }
    ctx.closePath();
    
    // Enhanced fill with subtle gradient
    if (!isReserved && entryProgress > 0.5) {
        const gradient = ctx.createRadialGradient(x, y - finalSize * 0.3, 0, x, y, finalSize);
        gradient.addColorStop(0, lightenColor(color, 30));
        gradient.addColorStop(1, color);
        ctx.fillStyle = gradient;
    } else {
        ctx.fillStyle = color;
    }
    ctx.fill();

    // Shadow for depth (only when not reserved)
    if (!isReserved && entryProgress > 0.8) {
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = isHovered ? 20 : 10;
        ctx.shadowOffsetY = isHovered ? 8 : 4;
        ctx.fill();
        ctx.restore();
    }

    if (isReserved) {
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.setLineDash([]);
    } else if (isGlow || isBlinking || isIdleBlinking || isHovered || isSearchMatch) {
        const glowColor = isSearchMatch ? '#ffd700' : (isIdleBlinking ? "rgba(255,255,255,0.5)" : "white");
        ctx.strokeStyle = glowColor; 
        ctx.lineWidth = isIdleBlinking ? 2 : (isHovered ? 4 : 3); 
        ctx.shadowBlur = isIdleBlinking ? 5 : (isHovered ? 25 : 15); 
        ctx.shadowColor = isSearchMatch ? '#ffd700' : "white"; 
        ctx.stroke();
    } else {
        ctx.strokeStyle = "rgba(255,255,255,0.12)"; 
        ctx.lineWidth = 1; 
        ctx.stroke();
    }
    ctx.restore();
}

/**
 * Lighten a hex color
 */
function lightenColor(color, percent) {
    const num = parseInt(color.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    return `rgb(${R}, ${G}, ${B})`;
}

function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '', lines = [];
    for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        if (ctx.measureText(testLine).width > maxWidth && n > 0) { 
            lines.push(line); 
            line = words[n] + ' '; 
        } else { 
            line = testLine; 
        }
    }
    lines.push(line);
    const startY = y - ((lines.length - 1) * lineHeight) / 2;
    lines.forEach((l, i) => ctx.fillText(l.trim(), x, startY + (i * lineHeight)));
}

/**
 * Spawn particles along prerequisite paths
 */
function spawnPrereqParticle(fromX, fromY, toX, toY, color) {
    prereqAnimState.particles.push({
        startX: fromX,
        startY: fromY,
        endX: toX,
        endY: toY,
        progress: 0,
        speed: 0.008 + Math.random() * 0.006,
        color: color,
        size: 3 + Math.random() * 3
    });
}

/**
 * Update and draw particles
 */
function updateAndDrawParticles() {
    prereqAnimState.particles = prereqAnimState.particles.filter(p => {
        p.progress += p.speed;
        
        if (p.progress >= 1) return false;
        
        const t = Easing.easeInOutQuad(p.progress);
        const x = p.startX + (p.endX - p.startX) * t;
        const y = p.startY + (p.endY - p.startY) * t;
        
        // Draw particle with trail
        ctx.save();
        ctx.globalAlpha = 1 - p.progress * 0.5;
        
        // Glow
        ctx.beginPath();
        ctx.arc(x, y, p.size * 2, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        
        // Core
        ctx.beginPath();
        ctx.arc(x, y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        
        ctx.restore();
        return true;
    });
}

/**
 * Draw prerequisite connections with animated flows
 */
function drawPrerequisiteConnections(activeTile) {
    if (!activeTile || !activeTile.prereqs || activeTile.prereqs.length === 0) return;
    
    const activeCoords = getPixelCoords(activeTile.q, activeTile.r);
    const sectionColor = SECTION_COLORS[activeTile.section] || '#ffffff';
    const time = Date.now();
    
    activeTile.prereqs.forEach(prereqId => {
        const prereq = knowledgeData.find(t => t.id === prereqId);
        if (!prereq) return;
        
        const prereqCoords = getPixelCoords(prereq.q, prereq.r);
        
        const midX = (activeCoords.x + prereqCoords.x) / 2;
        const midY = (activeCoords.y + prereqCoords.y) / 2;
        const dx = activeCoords.x - prereqCoords.x;
        const dy = activeCoords.y - prereqCoords.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        const curveAmount = Math.min(dist * 0.25, scale * 0.8);
        const perpX = (-dy / dist) * curveAmount;
        const perpY = (dx / dist) * curveAmount;
        
        const ctrlX = midX + perpX;
        const ctrlY = midY + perpY;
        
        ctx.save();
        
        // Draw glow layer
        ctx.strokeStyle = sectionColor;
        ctx.lineWidth = 10;
        ctx.globalAlpha = 0.2;
        ctx.shadowColor = sectionColor;
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        
        // Draw main line
        ctx.shadowBlur = 0;
        ctx.strokeStyle = sectionColor;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        
        // Animated flowing dashes
        const dashOffset = (time / 30) % 24;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 18]);
        ctx.lineDashOffset = -dashOffset;
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Arrow head
        const angle = Math.atan2(activeCoords.y - ctrlY, activeCoords.x - ctrlX);
        const arrowSize = Math.max(12, scale * 0.18);
        
        ctx.fillStyle = sectionColor;
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.moveTo(activeCoords.x, activeCoords.y);
        ctx.lineTo(
            activeCoords.x - arrowSize * Math.cos(angle - Math.PI/6),
            activeCoords.y - arrowSize * Math.sin(angle - Math.PI/6)
        );
        ctx.lineTo(
            activeCoords.x - arrowSize * 0.6 * Math.cos(angle),
            activeCoords.y - arrowSize * 0.6 * Math.sin(angle)
        );
        ctx.lineTo(
            activeCoords.x - arrowSize * Math.cos(angle + Math.PI/6),
            activeCoords.y - arrowSize * Math.sin(angle + Math.PI/6)
        );
        ctx.closePath();
        ctx.fill();
        
        // Pulsing circle at source
        const pulseScale = 1 + 0.3 * Math.sin(time / 300);
        ctx.beginPath();
        ctx.arc(prereqCoords.x, prereqCoords.y, 6 * pulseScale, 0, Math.PI * 2);
        ctx.fillStyle = sectionColor;
        ctx.shadowColor = sectionColor;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
    });
}

/**
 * Main rendering loop
 */
function render() {
    if (knowledgeData.length === 0) {
        requestAnimationFrame(render);
        return;
    }

    // Check if entry animation is complete
    const entryElapsed = Date.now() - entryAnimationStartTime;
    if (entryAnimationActive && entryElapsed > ENTRY_ANIMATION_DURATION + ENTRY_TILE_DURATION) {
        entryAnimationActive = false;
    }

    // Camera panning animation
    if (isPanning) {
        offsetX += (targetOffsetX - offsetX) * panSpeed;
        offsetY += (targetOffsetY - offsetY) * panSpeed;

        if (Math.abs(targetOffsetX - offsetX) < 0.1 && Math.abs(targetOffsetY - offsetY) < 0.1) {
            offsetX = targetOffsetX;
            offsetY = targetOffsetY;
            isPanning = false;
        }
    }

    const time = Date.now();
    
    const globalAlphaFactor = 0.97 + 0.03 * Math.sin(time / 2500);
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.globalAlpha = globalAlphaFactor;

    const activeTile = activeTileId ? knowledgeData.find(t => t.id === activeTileId) : null;
    if (blinkTileId && time - blinkStartTime > 3000) blinkTileId = null;

    const isSystemIdle = !activeTileId && !blinkTileId && !entryAnimationActive && !highlightedSection;

    // Idle blink scheduling
    if (isSystemIdle && knowledgeData.length > 0) {
        const currentBlinkCount = Object.keys(idleBlinkState).length;
        const timeSinceLastBlink = time - lastBlinkTime;
        
        if (currentBlinkCount < MAX_CONCURRENT_BLINKS && timeSinceLastBlink > IDLE_BLINK_INTERVAL) {
            const availableTiles = knowledgeData.filter(t => !idleBlinkState[t.id] && !t.isReserved);
            if (availableTiles.length > 0) {
                const randomTile = availableTiles[Math.floor(Math.random() * availableTiles.length)];
                idleBlinkState[randomTile.id] = time;
                lastBlinkTime = time;
            }
        }
    }

    // Check if section highlight should expire
    if (highlightedSection) {
        const elapsed = time - highlightedSectionTime;
        if (elapsed >= SECTION_HIGHLIGHT_DURATION) {
            highlightedSection = null;
            document.getElementById('status').innerText = "Explore the Knowledge Map";
        }
    }

    // Draw tiles
    knowledgeData.forEach((tile, index) => {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        
        // Entry animation progress
        const entryProgress = getEntryAnimationProgress(index);
        if (entryProgress === 0) return; // Don't draw if not yet visible
        
        // Exit animation progress (1 = visible, 0 = gone)
        const exitProgress = getExitAnimationProgress(index);
        if (exitProgress === 0) return; // Don't draw if already gone
        
        // Combined animation progress
        const animProgress = Math.min(entryProgress, exitProgress);
        
        let alpha = activeTile ? 0.12 : 1.0;
        let glow = false;
        let isIdleBlinking = false;
        const isReserved = tile.isReserved === true;
        const isHovered = tile.id === hoveredTileId && !isReserved;
        const isSearchMatch = searchResults.includes(tile.id);

        // Idle blinking
        if (isSystemIdle && !isReserved) {
            if (idleBlinkState[tile.id]) {
                const elapsed = time - idleBlinkState[tile.id];
                if (elapsed < IDLE_BLINK_DURATION) {
                    isIdleBlinking = tile.id;
                } else {
                    delete idleBlinkState[tile.id];
                }
            }
        } else if (!highlightedSection) {
            // Clear idle blinks unless we're showing section highlight
            delete idleBlinkState[tile.id];
        }

        // Highlight logic
        if (activeTile && !isReserved) {
            const isSelf = tile.id === activeTileId;
            const isSameTopicGroup = activeTile.topicGroup && tile.topicGroup === activeTile.topicGroup;
            const isPrereq = activeTile.prereqs && activeTile.prereqs.includes(tile.id);
            
            if (isSelf || isSameTopicGroup || isPrereq) { 
                alpha = 1.0; 
                glow = isSelf || isPrereq; 
            }
        }

        // Search results override
        if (searchQuery && searchResults.length > 0) {
            alpha = isSearchMatch ? 1.0 : 0.15;
        }

        // Section highlight (from legend click)
        let isSectionHighlight = false;
        if (highlightedSection && !activeTile && !searchQuery) {
            const isInSection = tile.section === highlightedSection && !isReserved;
            if (isInSection) {
                alpha = 1.0;
                isSectionHighlight = true;
                glow = true;
            } else {
                alpha = 0.15;
            }
        }

        const color = SECTION_COLORS[tile.section] || '#888888';
        drawHexagon(x, y, scale * 0.95, color, alpha, glow, tile.id === blinkTileId, isIdleBlinking, isReserved, animProgress, isHovered, isSearchMatch || isSectionHighlight);
        
        // Part number background
        const partMatch = tile.id.match(/-(\d+)$/);
        if (partMatch && !isReserved && animProgress > 0.8) {
            const partNum = partMatch[1];
            ctx.save();
            
            const numSize = scale * 1.1;
            ctx.font = `bold ${numSize}px 'Segoe UI', sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.55)";
            ctx.globalAlpha = alpha * animProgress * 0.6;
            
            ctx.fillText(partNum, x, y);
            ctx.restore();
        }
        
        // Text rendering
        const zoomOpacity = Math.max(0, Math.min(1, (scale - 40) / (60 - 40)));

        if (zoomOpacity > 0 && animProgress > 0.5) {
            ctx.save();
            
            ctx.fillStyle = isReserved ? "rgba(255,255,255,0.5)" : "white"; 
            ctx.textAlign = "center";
            const fontSize = scale / 4.5; 
            ctx.font = isReserved ? `italic ${fontSize}px 'Segoe UI', sans-serif` : `bold ${fontSize}px 'Segoe UI', sans-serif`;

            const textBaseAlpha = isReserved ? 0.5 : (alpha > 0.5) ? 1.0 : 0.7;
            ctx.globalAlpha = textBaseAlpha * globalAlphaFactor * zoomOpacity * animProgress;

            wrapText(tile.title, x, y, scale * 1.3, fontSize * 1.2);
            
            ctx.restore();
        }
    });
    
    // Draw prerequisite connections and particles
    if (activeTile) {
        drawPrerequisiteConnections(activeTile);
    }
    
    // Selection hint UI
    if (activeTile && !activeTile.isReserved) {
        const { x, y } = getPixelCoords(activeTile.q, activeTile.r);
        const sectionColor = SECTION_COLORS[activeTile.section] || '#3498db';
        
        const text = "TAP TO OPEN";
        ctx.font = "bold 14px 'Segoe UI', sans-serif";
        const textWidth = ctx.measureText(text).width;
        const hintY = y + scale * 0.5;
        
        // Pulsing glow effect
        const pulsePhase = (Math.sin(time / 300) + 1) / 2;
        const glowIntensity = 0.6 + pulsePhase * 0.4;
        
        // Outer glow
        ctx.save();
        ctx.shadowColor = sectionColor;
        ctx.shadowBlur = 15 + pulsePhase * 10;
        
        // Gradient background pill
        const padding = 14;
        const pillHeight = 28;
        const pillWidth = textWidth + padding * 2;
        const pillX = x - pillWidth / 2;
        const pillY = hintY - pillHeight / 2;
        
        const gradient = ctx.createLinearGradient(pillX, pillY, pillX + pillWidth, pillY + pillHeight);
        gradient.addColorStop(0, sectionColor);
        gradient.addColorStop(1, lightenColor(sectionColor, -20));
        
        ctx.globalAlpha = glowIntensity;
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 14);
        ctx.fill();
        
        // Border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        ctx.restore();
        
        // Text with subtle bounce
        const bounceOffset = Math.sin(time / 200) * 1.5;
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 13px 'Segoe UI', sans-serif";
        ctx.fillText(text, x, hintY + bounceOffset);
    }

    requestAnimationFrame(render);
}

/**
 * Update info panel and Tessera guide
 */
function updateInfoPanel(tile) {
    // Update Tessera with the selected tile
    updateTesseraForTile(tile);
}

/**
 * Smoothly pans camera to center tile
 */
function panToTile(tile) {
    const coords = getPixelCoords(tile.q, tile.r);
    const rawMapX = coords.x - offsetX;
    const rawMapY = coords.y - offsetY;

    targetOffsetX = (window.innerWidth / 2) - rawMapX;
    targetOffsetY = (window.innerHeight / 2) - rawMapY;
    
    isPanning = true;
}

/**
 * Pan to section center and highlight all tiles in that section
 */
function panToSection(sectionId) {
    // Clear any existing selection/search state
    activeTileId = null;
    searchQuery = '';
    searchResults = [];
    document.getElementById('search-input').value = '';
    updateInfoPanel(null);
    
    // Get all tiles in this section (excluding reserved)
    const sectionTiles = knowledgeData.filter(t => t.section === sectionId && !t.isReserved);
    
    if (sectionTiles.length === 0) return;
    
    // Calculate the center of all tiles in this section
    let sumQ = 0, sumR = 0;
    sectionTiles.forEach(tile => {
        sumQ += tile.q;
        sumR += tile.r;
    });
    const centerQ = sumQ / sectionTiles.length;
    const centerR = sumR / sectionTiles.length;
    
    // Convert to pixel coordinates and pan
    const centerX = scale * Math.sqrt(3) * (centerQ + centerR / 2);
    const centerY = scale * (3 / 2 * centerR);
    
    targetOffsetX = (window.innerWidth / 2) - centerX;
    targetOffsetY = (window.innerHeight / 2) - centerY;
    isPanning = true;
    
    // Set the highlighted section with timestamp
    highlightedSection = sectionId;
    highlightedSectionTime = Date.now();
    
    // Update status
    const sectionNames = {
        'I': 'Linear Algebra to Algebraic Foundations',
        'II': 'Calculus to Optimization & Analysis',
        'III': 'Probability & Statistics',
        'IV': 'Discrete Mathematics & Algorithms',
        'V': 'Machine Learning'
    };
    document.getElementById('status').innerText = `Section ${sectionId}: ${sectionNames[sectionId] || sectionId} (${sectionTiles.length} topics)`;
}

/**
 * Search functionality
 */
function performSearch(query) {
    searchQuery = query.toLowerCase().trim();
    
    // Clear section highlight when searching
    highlightedSection = null;
    
    if (!searchQuery) {
        searchResults = [];
        return;
    }
    
    searchResults = knowledgeData
        .filter(tile => {
            if (tile.isReserved) return false;
            const titleMatch = tile.title.toLowerCase().includes(searchQuery);
            const keywordMatch = tile.keywords && tile.keywords.some(k => k.toLowerCase().includes(searchQuery));
            return titleMatch || keywordMatch;
        })
        .map(t => t.id);
    
    // Pan to first result
    if (searchResults.length > 0) {
        const firstResult = knowledgeData.find(t => t.id === searchResults[0]);
        if (firstResult) {
            panToTile(firstResult);
            activeTileId = firstResult.id;
            updateInfoPanel(firstResult);
        }
    }
    
    document.getElementById('status').innerText = searchResults.length > 0 
        ? `Found ${searchResults.length} result${searchResults.length > 1 ? 's' : ''}`
        : 'No results found';
}

// --- INTERACTION LOGIC ---

function handleInteraction(clientX, clientY) {
    if (isDragging) return;

    // Clear section highlight on any interaction
    highlightedSection = null;

    let hit = false;
    for (const tile of knowledgeData) {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        
        if (Math.hypot(x - clientX, y - clientY) < scale * 0.8) {
            hit = true;
            
            if (tile.isReserved) {
                activeTileId = tile.id;
                document.getElementById('status').innerText = `Coming Soon - New content planned`;
                updateInfoPanel(tile);
                panToTile(tile);
                break;
            }
            
            if (activeTileId === tile.id) {
                if (tile.url) {
                    triggerExitAnimation(tile.url);
                }
            } else {
                activeTileId = tile.id;
                
                const prereqCount = tile.prereqs?.length || 0;
                const prereqText = prereqCount > 0 ? ` (${prereqCount} prerequisites)` : '';
                document.getElementById('status').innerText = `Selected: ${tile.title}${prereqText}`;
                
                updateInfoPanel(tile);
                panToTile(tile);
            }
            break;
        }
    }

    if (!hit) {
        activeTileId = null;
        isPanning = false;
        updateInfoPanel(null);
        document.getElementById('status').innerText = "Explore the Knowledge Map";
        
        // Clear search
        if (searchQuery) {
            searchQuery = '';
            searchResults = [];
            document.getElementById('search-input').value = '';
        }
    }
}

function handleMouseMove(clientX, clientY) {
    let found = null;
    for (const tile of knowledgeData) {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        if (Math.hypot(x - clientX, y - clientY) < scale * 0.8) {
            found = tile.id;
            break;
        }
    }
    
    if (hoveredTileId !== found) {
        hoveredTileId = found;
        canvas.style.cursor = found ? 'pointer' : 'grab';
    }
}

// Mouse Handlers
window.addEventListener('mousedown', e => { 
    document.getElementById('search-input').blur();

    if (isTouchInteraction) return; 
    isDragging = false; 
    startX = e.clientX; startY = e.clientY; 
    lastX = e.clientX; lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
});

window.addEventListener('mousemove', e => {
    if (isTouchInteraction) return;
    
    handleMouseMove(e.clientX, e.clientY);
    
    if (e.buttons === 1) {
        if (Math.hypot(e.clientX - startX, e.clientY - startY) > 5) isDragging = true;
        if (isDragging) { 
            offsetX += e.clientX - lastX; 
            offsetY += e.clientY - lastY; 
        }
        lastX = e.clientX; lastY = e.clientY;
    }
});

window.addEventListener('mouseup', e => {
    if (isTouchInteraction) return;
    canvas.style.cursor = hoveredTileId ? 'pointer' : 'grab';
    // Don't handle interaction if clicking on Tessera or UI elements
    const tesseraContainer = document.getElementById('tessera-container');
    if (tesseraContainer && tesseraContainer.contains(e.target)) return;
    if (!isDragging) handleInteraction(e.clientX, e.clientY);
});

window.addEventListener('wheel', e => {
    const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
    scale = Math.min(Math.max(minScale, scale * zoomFactor), maxScale);
}, { passive: false });

// Touch Handlers
canvas.addEventListener('touchstart', e => {

    // hide keyboard when touching canvas
    document.getElementById('search-input').blur();

    isTouchInteraction = true; 
    if (e.touches.length === 1) {
        isDragging = false;
        startX = e.touches[0].clientX; startY = e.touches[0].clientY;
        lastX = startX; lastY = startY;
    } else if (e.touches.length === 2) {
        initialPinchDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX, 
            e.touches[0].clientY - e.touches[1].clientY
        );
        initialScale = scale;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        if (Math.hypot(x - startX, y - startY) > 5) isDragging = true;
        offsetX += x - lastX; offsetY += y - lastY;
        lastX = x; lastY = y;
    } else if (e.touches.length === 2) {
        const dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX, 
            e.touches[0].clientY - e.touches[1].clientY
        );
        if (initialPinchDist > 0) {
            scale = Math.min(Math.max(minScale, initialScale * (dist / initialPinchDist)), maxScale);
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault(); 
    if (!isDragging && e.changedTouches.length === 1) {
        handleInteraction(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
    setTimeout(() => isTouchInteraction = false, 500); 
});

// Keyboard navigation
window.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        activeTileId = null;
        highlightedSection = null;
        updateInfoPanel(null);
        document.getElementById('status').innerText = "Explore the Knowledge Map";
        searchQuery = '';
        searchResults = [];
        document.getElementById('search-input').value = '';
    }
    if (e.key === 'Enter' && activeTileId) {
        const tile = knowledgeData.find(t => t.id === activeTileId);
        if (tile && tile.url) triggerExitAnimation(tile.url);
    }
});

// Search input
document.getElementById('search-input').addEventListener('input', e => {
    performSearch(e.target.value);
});

document.getElementById('search-input').addEventListener('keydown', e => {
    if (e.key === 'Enter' && searchResults.length > 0) {
        const tile = knowledgeData.find(t => t.id === searchResults[0]);
        if (tile && tile.url) {
            triggerExitAnimation(tile.url);
        }
    }
});

// Zoom controls
document.getElementById('zoom-in').addEventListener('click', () => {
    scale = Math.min(maxScale, scale * 1.2);
});

document.getElementById('zoom-out').addEventListener('click', () => {
    scale = Math.max(minScale, scale * 0.8);
});

// Legend hover effects and click handlers
document.querySelectorAll('.legend-item').forEach(item => {
    item.addEventListener('mouseenter', () => {
        const section = item.dataset.section;
        // Could highlight all tiles of this section on hover (optional)
    });
    
    // Click to pan, highlight section, and have Tessera explain
    item.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent event from bubbling to canvas
        const section = item.dataset.section;
        if (section) {
            panToSection(section);
            // Trigger Tessera to explain the section
            triggerTesseraSectionExplain(section);
        }
    });
});

// Initialize
window.addEventListener('resize', setup);
window.addEventListener('mousedown', () => isPanning = false);
window.addEventListener('wheel', () => isPanning = false);

// Handle back navigation - reset state when page is shown from bfcache
window.addEventListener('pageshow', (event) => {
    if (event.persisted) {
        // Page was restored from bfcache (back/forward navigation)
        resetMapState();
    }
});

/**
 * Reset map state for fresh start (used when navigating back)
 */
function resetMapState() {
    // Reset animation states
    exitAnimationActive = false;
    exitTargetUrl = null;
    entryAnimationActive = true;
    entryAnimationStartTime = Date.now();
    
    // Reset UI opacity
    const uiElements = ['#ui-layer', '#search-container', '#home-btn', '#legend', '#zoom-controls', '#tessera-container'];
    uiElements.forEach(selector => {
        const el = document.querySelector(selector);
        if (el) {
            el.style.transition = 'none';
            el.style.opacity = '1';
        }
    });
    
    // Reset view
    scale = 50;
    offsetX = window.innerWidth / 2;
    offsetY = window.innerHeight / 2;
    activeTileId = null;
    hoveredTileId = null;
    highlightedSection = null;
    searchQuery = '';
    searchResults = [];
    document.getElementById('search-input').value = '';
    document.getElementById('status').innerText = "Explore the Knowledge Map";
    
    // Reset Tessera completely
    tesseraState.showingSectionExplain = false;
    tesseraState.lastTileId = null;
    tesseraState.clickCount = 0;
    if (tesseraState.bubbleTimeout) {
        clearTimeout(tesseraState.bubbleTimeout);
    }
    
    // Show welcome message again
    setTesseraExpression('wave');
    updateTesseraMessage(tesseraDefaultMessages.welcome);
    
    // Re-trigger Tessera entering animation
    const character = document.getElementById('tessera-character');
    if (character) {
        character.classList.add('entering');
        setTimeout(() => {
            character.classList.remove('entering');
            setTesseraExpression('idle');
        }, 2500);
    }
}

async function init() {
    setup();
    const loaded = await loadCurriculumData();
    if (loaded) {
        render();
        initTessera();
    }
}

init();
</script>
</body>
</html>