<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Math-CS Compass | Knowledge Map</title>
    <style>
        :root { 
            --bg-color: #0b0e14; 
            --text-color: #e0e0e0; 
        }

        /* Essential Mobile Styling */
        html, body { 
            margin: 0; 
            padding: 0;
            width: 100%; 
            height: 100%;
            background: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            -webkit-text-size-adjust: 100%; 
            position: fixed; 
        }

        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
            image-rendering: -webkit-optimize-contrast;
        }

        /* UI Overlay */
        #ui-layer { 
            position: absolute; 
            top: env(safe-area-inset-top, 20px); 
            left: 20px; 
            pointer-events: none; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); 
            z-index: 10; 
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            left: 20px;
            background: rgba(11, 14, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: auto;
        }

        #legend h4 {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            color: #fff;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--text-color);
        }

        /* Home button */
        #home-btn {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            background: rgba(11, 14, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 10px 16px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            z-index: 10;
            transition: all 0.2s;
        }

        #home-btn:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }

        @media (max-width: 768px) {
            #legend {
                font-size: 0.7rem;
                padding: 8px 12px;
            }
            #legend h4 {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1 style="margin:0; font-size: 1.2rem;">MATH-CS COMPASS</h1>
    <div id="status" style="font-size: 0.9rem; opacity: 0.8;">Explore the Knowledge Map</div>
</div>

<a id="home-btn" href="/index.html">← Back to Home</a>

<div id="legend">
    <h4>Sections</h4>
    <div class="legend-item">
        <div class="legend-color" style="background: #1565c0;"></div>
        <span>I - Linear Algebra to Algebraic Foundations</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #2e7d32;"></div>
        <span>II - Calculus to Optimization & Analysis</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #c62828;"></div>
        <span>III - Probability & Statistics</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #6a1b9a;"></div>
        <span>IV - Discrete Mathematics & Algorithms</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #ef6c00;"></div>
        <span>V - Machine Learning</span>
    </div>
</div>

<div id="loading">Loading curriculum data...</div>

<canvas id="mapCanvas"></canvas>

<script>
/**
 * MATH-CS COMPASS: HEXAGONAL KNOWLEDGE MAP SYSTEM
 * @author Yusuke Yokota
 * @version 5.0.0 (January 2026)
 * 
 * Now imports from centralized curriculum.json for single source of truth.
 * 
 * Technical Specs:
 * - Cube Coordinates (q, r, s) where q+r+s=0
 * - LOD (Level of Detail) rendering
 * - Sequential Path Highlighting with prerequisite connections
 * - Dynamic data loading from curriculum.json
 */

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

// State
let scale = 80;
const minScale = 40, maxScale = 250;
let offsetX = window.innerWidth / 2;
let offsetY = window.innerHeight / 2;

// Camera animation state
let targetOffsetX = offsetX;
let targetOffsetY = offsetY;
let isPanning = false;        // True when camera is auto-moving

// Tile animation
let activeTileId = null;
let blinkTileId = null; 
let blinkStartTime = 0;
let isTouchInteraction = false;
let isDragging = false;
let startX = 0, startY = 0;
let lastX = 0, lastY = 0;
let initialPinchDist = 0;
let initialScale = 0;

// Data (loaded from curriculum.json)
let knowledgeData = [];
let SECTION_COLORS = {};

// Animation settings
const IDLE_BLINK_DURATION = 4000;      // How long each blink animation lasts
const IDLE_BLINK_INTERVAL = 2500;      // Minimum ms between starting new blinks
const MAX_CONCURRENT_BLINKS = 2;       // Maximum tiles blinking simultaneously
const idleBlinkState = {};
let lastBlinkTime = 0;

const panSpeed = 0.1; // Easing factor (0.1 = smooth, 0.5 = snappy)

/**
 * Load curriculum data from JSON file
 */
async function loadCurriculumData() {
    try {
        // Try relative path first (for local testing), then absolute
        let response;
        try {
            response = await fetch('../data/curriculum.json');
            if (!response.ok) throw new Error('Relative path failed');
        } catch {
            response = await fetch('/data/curriculum.json');
        }
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        
        // Extract section colors
        SECTION_COLORS = data.sectionColors || {};
        SECTION_COLORS['HOME'] = '#888888'; // Gray for home
        
        // Build knowledge data array
        knowledgeData = [];
        
        // Add home node
        if (data.homeNode) {
            knowledgeData.push({
                id: data.homeNode.id,
                section: 'HOME',
                title: data.homeNode.title,
                url: data.homeNode.url,
                q: data.homeNode.mapCoords.q,
                r: data.homeNode.mapCoords.r,
                prereqs: []
            });
        }
        
        // Add all parts from all sections
        Object.entries(data.sections).forEach(([sectionId, section]) => {
            section.parts.forEach(part => {
                knowledgeData.push({
                    id: part.id,
                    section: sectionId,
                    title: part.title,
                    // URL relative to map folder
                    url: '../' + section.baseUrl + part.url,
                    q: part.mapCoords.q,
                    r: part.mapCoords.r,
                    topicGroup: part.topicGroup || null,  // Use topicGroup for related highlighting
                    prereqs: part.prereqs || []
                });
            });
            
            // Add reserved slots (Coming Soon tiles)
            if (section.reservedSlots) {
                section.reservedSlots.forEach((slot, index) => {
                    knowledgeData.push({
                        id: `${sectionId}-reserved-${index}`,
                        section: sectionId,
                        title: 'Coming Soon',
                        url: null,  // No URL for reserved slots
                        q: slot.q,
                        r: slot.r,
                        topicGroup: null,
                        prereqs: [],
                        isReserved: true  // Flag to identify reserved slots
                    });
                });
            }
        });
        
        console.log(`Loaded ${knowledgeData.length} tiles from curriculum data`);
        
        // Hide loading indicator
        document.getElementById('loading').style.display = 'none';
        
        return true;
    } catch (error) {
        console.error('Failed to load curriculum data:', error);
        document.getElementById('loading').textContent = 'Error loading data. Please refresh.';
        return false;
    }
}

function setup() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.scale(dpr, dpr);
    if (offsetX === 0) { 
        offsetX = window.innerWidth / 2; 
        offsetY = window.innerHeight / 2; 
    }
}

function getPixelCoords(q, r) {
    const x = scale * Math.sqrt(3) * (q + r/2);
    const y = scale * (3/2 * r); 
    return { x: x + offsetX, y: y + offsetY };
}

function drawHexagon(x, y, size, color, alpha = 1, isGlow = false, isBlinking = false, isIdleBlinking = false, isReserved = false) {
    ctx.save();
    let finalAlpha = alpha;

    if (isBlinking) {
        finalAlpha = 0.3 + Math.abs(Math.sin(Date.now() / 2000)) * 0.7;
    } else if (isIdleBlinking) {
        if (idleBlinkState[isIdleBlinking] !== undefined) {
            const elapsed = Date.now() - idleBlinkState[isIdleBlinking];
            const progress = elapsed / IDLE_BLINK_DURATION;
            finalAlpha = 0.8 + 0.2 * Math.sin(progress * Math.PI * 2 - Math.PI / 2);
        }
    }
    
    // Reserved slots are always dimmed
    if (isReserved) {
        finalAlpha = 0.25;
    }

    ctx.globalAlpha = finalAlpha;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 6) + (i * Math.PI / 3);
        ctx.lineTo(x + size * Math.cos(angle), y + size * Math.sin(angle));
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();

    if (isReserved) {
        // Dashed border for reserved slots
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.setLineDash([]);
    } else if (isGlow || isBlinking || isIdleBlinking) {
        ctx.strokeStyle = isIdleBlinking ? "rgba(255,255,255,0.5)" : "white"; 
        ctx.lineWidth = isIdleBlinking ? 2 : 3; 
        ctx.shadowBlur = isIdleBlinking ? 5 : 15; 
        ctx.shadowColor = "white"; 
        ctx.stroke();
    } else {
        ctx.strokeStyle = "rgba(255,255,255,0.15)"; 
        ctx.lineWidth = 1; 
        ctx.stroke();
    }
    ctx.restore();
}

function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '', lines = [];
    for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        if (ctx.measureText(testLine).width > maxWidth && n > 0) { 
            lines.push(line); 
            line = words[n] + ' '; 
        } else { 
            line = testLine; 
        }
    }
    lines.push(line);
    const startY = y - ((lines.length - 1) * lineHeight) / 2;
    lines.forEach((l, i) => ctx.fillText(l.trim(), x, startY + (i * lineHeight)));
}

/**
 * Draw prerequisite connections as curved lines with colored glow
 * Lines use the section color and are drawn with a glow effect for visibility
 */
function drawPrerequisiteConnections(activeTile) {
    if (!activeTile || !activeTile.prereqs || activeTile.prereqs.length === 0) return;
    
    const activeCoords = getPixelCoords(activeTile.q, activeTile.r);
    const sectionColor = SECTION_COLORS[activeTile.section] || '#ffffff';
    
    activeTile.prereqs.forEach(prereqId => {
        const prereq = knowledgeData.find(t => t.id === prereqId);
        if (!prereq) return;
        
        const prereqCoords = getPixelCoords(prereq.q, prereq.r);
        
        // Calculate control point for curve
        const midX = (activeCoords.x + prereqCoords.x) / 2;
        const midY = (activeCoords.y + prereqCoords.y) / 2;
        const dx = activeCoords.x - prereqCoords.x;
        const dy = activeCoords.y - prereqCoords.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Perpendicular offset - scales with distance but caps at reasonable value
        const curveAmount = Math.min(dist * 0.25, scale * 0.8);
        const perpX = (-dy / dist) * curveAmount;
        const perpY = (dx / dist) * curveAmount;
        
        const ctrlX = midX + perpX;
        const ctrlY = midY + perpY;
        
        ctx.save();
        
        // Draw glow layer (thick, blurred)
        ctx.strokeStyle = sectionColor;
        ctx.lineWidth = 8;
        ctx.globalAlpha = 0.3;
        ctx.shadowColor = sectionColor;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        
        // Draw main line (solid color)
        ctx.shadowBlur = 0;
        ctx.strokeStyle = sectionColor;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        
        // Draw animated dashes on top (white for contrast)
        const dashOffset = (Date.now() / 50) % 20; // Animate the dashes
        ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 12]);
        ctx.lineDashOffset = -dashOffset;
        ctx.beginPath();
        ctx.moveTo(prereqCoords.x, prereqCoords.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, activeCoords.x, activeCoords.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw arrow head at destination
        const angle = Math.atan2(activeCoords.y - ctrlY, activeCoords.x - ctrlX);
        const arrowSize = Math.max(10, scale * 0.15);
        
        // Arrow with fill
        ctx.fillStyle = sectionColor;
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.moveTo(activeCoords.x, activeCoords.y);
        ctx.lineTo(
            activeCoords.x - arrowSize * Math.cos(angle - Math.PI/7),
            activeCoords.y - arrowSize * Math.sin(angle - Math.PI/7)
        );
        ctx.lineTo(
            activeCoords.x - arrowSize * 0.6 * Math.cos(angle),
            activeCoords.y - arrowSize * 0.6 * Math.sin(angle)
        );
        ctx.lineTo(
            activeCoords.x - arrowSize * Math.cos(angle + Math.PI/7),
            activeCoords.y - arrowSize * Math.sin(angle + Math.PI/7)
        );
        ctx.closePath();
        ctx.fill();
        
        // Draw circle at prereq source
        ctx.beginPath();
        ctx.arc(prereqCoords.x, prereqCoords.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = sectionColor;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
    });
}

/**
 * Main rendering loop using RequestAnimationFrame
 */
function render() {
    if (knowledgeData.length === 0) {
        requestAnimationFrame(render);
        return;
    }

    // --- 1. Camera Panning Animation (Easing) ---
    if (isPanning) {
        offsetX += (targetOffsetX - offsetX) * panSpeed;
        offsetY += (targetOffsetY - offsetY) * panSpeed;

        // Stop panning when coordinates are close enough
        if (Math.abs(targetOffsetX - offsetX) < 0.1 && Math.abs(targetOffsetY - offsetY) < 0.1) {
            offsetX = targetOffsetX;
            offsetY = targetOffsetY;
            isPanning = false;
        }
    }

    const time = Date.now();
    
    // Subtle breathing effect for global transparency
    const globalAlphaFactor = 0.97 + 0.03 * Math.sin(time / 2500);
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.globalAlpha = globalAlphaFactor;

    const activeTile = activeTileId ? knowledgeData.find(t => t.id === activeTileId) : null;
    if (blinkTileId && time - blinkStartTime > 3000) blinkTileId = null;

    const isSystemIdle = !activeTileId && !blinkTileId;

    // --- Controlled Idle Blink Scheduling ---
    // Only trigger new blinks when idle, respecting interval and max concurrent limits
    if (isSystemIdle && knowledgeData.length > 0) {
        const currentBlinkCount = Object.keys(idleBlinkState).length;
        const timeSinceLastBlink = time - lastBlinkTime;
        
        if (currentBlinkCount < MAX_CONCURRENT_BLINKS && timeSinceLastBlink > IDLE_BLINK_INTERVAL) {
            // Pick a random tile that isn't already blinking and isn't reserved
            const availableTiles = knowledgeData.filter(t => !idleBlinkState[t.id] && !t.isReserved);
            if (availableTiles.length > 0) {
                const randomTile = availableTiles[Math.floor(Math.random() * availableTiles.length)];
                idleBlinkState[randomTile.id] = time;
                lastBlinkTime = time;
            }
        }
    }

    // --- 2. Draw Tiles (Hexagons) - First layer ---
    knowledgeData.forEach(tile => {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        
        // Visual state logic
        let alpha = activeTile ? 0.15 : 1.0; // Dim non-selected tiles
        let glow = false;
        let isIdleBlinking = false;
        
        // Reserved slots don't participate in idle blinking
        const isReserved = tile.isReserved === true;

        // Handle random idle blinking (The "Pulse" of the system)
        if (isSystemIdle && !isReserved) {
            if (idleBlinkState[tile.id]) {
                const elapsed = time - idleBlinkState[tile.id];
                if (elapsed < IDLE_BLINK_DURATION) {
                    isIdleBlinking = tile.id;
                } else {
                    delete idleBlinkState[tile.id];
                }
            }
        } else {
            delete idleBlinkState[tile.id];
        }

        // Highlight logic for active/related tiles (reserved slots don't highlight)
        if (activeTile && !isReserved) {
            const isSelf = tile.id === activeTileId;
            // Highlight tiles in the same topic group (e.g., "abstract-algebra", "derivatives")
            const isSameTopicGroup = activeTile.topicGroup && tile.topicGroup === activeTile.topicGroup;
            const isPrereq = activeTile.prereqs && activeTile.prereqs.includes(tile.id);
            
            if (isSelf || isSameTopicGroup || isPrereq) { 
                alpha = 1.0; 
                glow = isSelf || isPrereq; 
            }
        }

        const color = SECTION_COLORS[tile.section] || '#888888';
        drawHexagon(x, y, scale * 0.95, color, alpha, glow, tile.id === blinkTileId, isIdleBlinking, isReserved);
        
        // --- Draw Part Number as faint background ---
        // Extract part number from id (e.g., "linalg-15" -> "15", "calc-3" -> "3")
        const partMatch = tile.id.match(/-(\d+)$/);
        if (partMatch && !isReserved) {
            const partNum = partMatch[1];
            ctx.save();
            
            // Large, faint number in the background
            const numSize = scale * 1.1;  // Large size
            ctx.font = `bold ${numSize}px 'Segoe UI', sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Very subtle - just enough to see when looking for it
            // Use section color with low opacity for a subtle tint
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
            ctx.globalAlpha = alpha;
            
            ctx.fillText(partNum, x, y);
            ctx.restore();
        }
        
        // --- 4. Draw Text (Final Optimized Version) ---
        // 1. Calculate zoom-based opacity independently.
        // Starts fading in at scale 40, reaches full opacity at scale 60.
        const zoomOpacity = Math.max(0, Math.min(1, (scale - 40) / (60 - 40)));

        // 2. Only proceed if text is actually visible (eliminates magic if-statements).
        if (zoomOpacity > 0) {
            ctx.save();
            
            ctx.fillStyle = isReserved ? "rgba(255,255,255,0.5)" : "white"; 
            ctx.textAlign = "center";
            const fontSize = scale / 3.0; 
            ctx.font = isReserved ? `italic ${fontSize}px 'Segoe UI', sans-serif` : `bold ${fontSize}px 'Segoe UI', sans-serif`;

            // 3. Fix the "Original Density" problem.
            // We ignore the tile's low alpha (0.15) and use a dedicated text visibility base.
            // Selected/Related tiles: 1.0, Others: 0.7 (still readable). Reserved: 0.5
            const textBaseAlpha = isReserved ? 0.5 : (alpha > 0.5) ? 1.0 : 0.7;

            // 4. Combine factors: Base Visibility * Breathing * Zoom Fade
            ctx.globalAlpha = textBaseAlpha * globalAlphaFactor * zoomOpacity;

            wrapText(tile.title, x, y, scale * 1.3, fontSize * 1.2);
            
            ctx.restore();
        }
    });
    
    // --- 3. Draw Prerequisite Connections (On top of tiles for visibility) ---
    if (activeTile) {
        drawPrerequisiteConnections(activeTile);
    }
    
    // --- 4. UI Overlay / Selection Hints ---
    if (activeTile) {
        const { x, y } = getPixelCoords(activeTile.q, activeTile.r);
        
        // Draw "Tap again to Open" with background for better visibility
        const text = "▼ Tap to Open";
        ctx.font = "bold 13px sans-serif";
        const textWidth = ctx.measureText(text).width;
        const textY = y + scale * 1.1;
        
        // Background pill
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        const padding = 8;
        const pillHeight = 20;
        ctx.beginPath();
        ctx.roundRect(x - textWidth/2 - padding, textY - pillHeight/2 - 2, textWidth + padding*2, pillHeight, 10);
        ctx.fill();
        
        // Text
        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
        ctx.textAlign = "center";
        ctx.fillText(text, x, textY);
    }

    requestAnimationFrame(render);
}


/**
 * Smoothly pans the camera to center the specified tile on screen.
 * @param {Object} tile - The tile data containing q and r coordinates.
 */
function panToTile(tile) {
    const coords = getPixelCoords(tile.q, tile.r);
    
    // Calculate the required offset to place (coords.x, coords.y) at the screen center
    // We calculate based on raw map coordinates (excluding current offsets)
    const rawMapX = coords.x - offsetX;
    const rawMapY = coords.y - offsetY;

    targetOffsetX = (window.innerWidth / 2) - rawMapX;
    targetOffsetY = (window.innerHeight / 2) - rawMapY;
    
    isPanning = true;
}

// --- INTERACTION LOGIC ---

/**
 * Handles mouse and touch interactions for tile selection and navigation.
 * Includes auto-panning to center the selected tile.
 */
function handleInteraction(clientX, clientY) {
    if (isDragging) return;

    let hit = false;
    for (const tile of knowledgeData) {
        const { x, y } = getPixelCoords(tile.q, tile.r);
        
        // Check if the click/tap is within the hexagon bounds
        if (Math.hypot(x - clientX, y - clientY) < scale * 0.8) {
            hit = true;
            
            // Handle reserved (Coming Soon) tiles
            if (tile.isReserved) {
                activeTileId = tile.id;
                document.getElementById('status').innerText = `Coming Soon - New content planned for this section`;
                panToTile(tile);
                break;
            }
            
            if (activeTileId === tile.id) {
                // Second tap on the same tile: Navigate to the content page
                if (tile.url) {
                    window.location.assign(tile.url);
                }
            } else {
                // First tap: Select the tile and trigger auto-panning
                activeTileId = tile.id;
                
                const prereqCount = tile.prereqs?.length || 0;
                const prereqText = prereqCount > 0 ? ` (${prereqCount} prerequisites)` : '';
                document.getElementById('status').innerText = `Selected: ${tile.title}${prereqText}`;
                
                // Trigger smooth camera movement to center this tile
                panToTile(tile);
            }
            break;
        }
    }

    // Deselect if clicking on empty background
    if (!hit) {
        activeTileId = null;
        isPanning = false; // Stop any ongoing auto-pan
        document.getElementById('status').innerText = "Explore the Knowledge Map";
    }
}

// Mouse Handlers
window.addEventListener('mousedown', e => { 
    if (isTouchInteraction) return; 
    isDragging = false; 
    startX = e.clientX; startY = e.clientY; 
    lastX = e.clientX; lastY = e.clientY;
});

window.addEventListener('mousemove', e => {
    if (isTouchInteraction) return;
    if (e.buttons === 1) {
        if (Math.hypot(e.clientX - startX, e.clientY - startY) > 5) isDragging = true;
        if (isDragging) { 
            offsetX += e.clientX - lastX; 
            offsetY += e.clientY - lastY; 
        }
        lastX = e.clientX; lastY = e.clientY;
    }
});

window.addEventListener('mouseup', e => {
    if (isTouchInteraction) return;
    if (!isDragging) handleInteraction(e.clientX, e.clientY);
});

window.addEventListener('wheel', e => {
    scale = Math.min(Math.max(minScale, scale - e.deltaY * 0.05), maxScale);
}, { passive: false });

// Touch Handlers
canvas.addEventListener('touchstart', e => {
    isTouchInteraction = true; 
    if (e.touches.length === 1) {
        isDragging = false;
        startX = e.touches[0].clientX; startY = e.touches[0].clientY;
        lastX = startX; lastY = startY;
    } else if (e.touches.length === 2) {
        initialPinchDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX, 
            e.touches[0].clientY - e.touches[1].clientY
        );
        initialScale = scale;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        if (Math.hypot(x - startX, y - startY) > 5) isDragging = true;
        offsetX += x - lastX; offsetY += y - lastY;
        lastX = x; lastY = y;
    } else if (e.touches.length === 2) {
        const dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX, 
            e.touches[0].clientY - e.touches[1].clientY
        );
        if (initialPinchDist > 0) {
            scale = Math.min(Math.max(minScale, initialScale * (dist / initialPinchDist)), maxScale);
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault(); 
    if (!isDragging && e.changedTouches.length === 1) {
        handleInteraction(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
    setTimeout(() => isTouchInteraction = false, 500); 
});

// Keyboard navigation
window.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        activeTileId = null;
        document.getElementById('status').innerText = "Explore the Knowledge Map";
    }
    if (e.key === 'Enter' && activeTileId) {
        const tile = knowledgeData.find(t => t.id === activeTileId);
        if (tile) window.location.assign(tile.url);
    }
});

// Initialize
window.addEventListener('resize', setup);
window.addEventListener('mousedown', () => isPanning = false);
window.addEventListener('wheel', () => isPanning = false);

async function init() {
    setup();
    const loaded = await loadCurriculumData();
    if (loaded) {
        render();
    }
}

init();
</script>
</body>
</html>